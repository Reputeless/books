---
title: C++ 集成体
author: onihusube
date: 2020/09/01
geometry:
  width: 188mm
  height: 263mm
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

この本はC++20をベースとして書かれています。基本的なところはC++17以前から変わってはいませんが、一部の仕様などはC++のバージョン毎に異なったりしています。もしかしたらお手元のコンパイラではエラーになったり挙動が異なったりするかもしれません。ご了承ください。

# 集成体（*Aggregate*）とは

集成体（*Aggregate*）とはいくつかの条件を満たした構造体（クラス）の事です（C形式の配列も集成体ですがここでは構造体だけに着目します）。とはいえ特別なものではなく、C++におけるC言語の構造体相当の構造体の事をそう呼びます。

```cpp
// 集成体の一例
struct aggregate {
  int n;
  double m;
  std::string str;
};

// 集成体初期化
aggregate agg = {20, 3.14, "Aggregate"};
```

このように、集成体では集成体初期化によって仮想的なコンストラクタが提供されるため、メンバを初期化するためにコンストラクタを書く必要が無くなります。

集成体は、単にいくつかのデータをまとめたタプルの様な型やすべてのメンバがパブリックであるようなクラスに対して活用することができ、余計なコンストラクタやセッター/ゲッターといったボイラープレートコードを削減することができます。

\clearpage

# 集成体の要件

ある構造体（クラス）が集成体となるためには次の条件を満たしていなければなりません。

1. ユーザー宣言コンストラクタおよび継承コンストラクタを持たない
2. `public`ではない（非`static`）メンバ変数を持たない
3. 仮想関数を持たない
4. `public`以外の継承をしていない

これらの規則を守ってさえいれば他の事は何をしても大丈夫です。この規則を守らなくても別にコンパイルエラーになったりせず、普通のクラスと同等の扱いになるだけです。

## 1. ユーザー宣言コンストラクタおよび継承コンストラクタを持たない

これは言い換えると、あらゆるコンストラクタを宣言していないということです。コピー/ムーブコンストラクタ、`= default`や`= delete`なコンストラクタも含めて、あらゆるコンストラクタを書いてはいけません。

```cpp
// これらはどれも集成体ではない

struct A1 {
  int n;

  A(int m) : n(m) {}
};

struct A2 {
  int n;

  A() = default;
};

struct A3 {
  int n;

  A(A&&) = default;
};
```

このようなコンストラクタ宣言が一つでもあるとその構造体は集成体ではなくなります。

もう一つの継承コンストラクタというのは、継承しているときに基底クラスのコンストラクタを有効化する`using`のことで、これによって基底クラスのコンストラクが利用可能になりますが、コンストラクタが宣言されているのと等価なので集成体ではなくなります。

```cpp
struct base {
  int n;

  base() : n(0) {}

  base(int m) : n(m) {}
};

// A1は集成体ではない
struct A1 : base {
  using base::base; // コンストラクタを継承する
};

// A2は集成体
struct A2 : base {};
```

この規定があることからわかるように、集成体になるにあたっては公開継承している分には問題ないですし、基底クラスが集成体でなくてもOKです。

## 2. `public`ではないメンバ変数を持たない

これはそのままの意味です。`private`とか`protected`でメンバ変数を宣言してはいけません。ただし、この場合のメンバ変数とは非静的なメンバ変数であって、`static`メンバ変数がどこにあろうと集成体となることを妨げません。

```cpp
// これは集成体ではない
class A1 {
  int n;  // classのデフォルトアクセス指定ははprivate
};

// これも集成体ではない
struct A2 {
  int n;

protected:
  int m;
};

// これは集成体
struct A3 {
  int n;

private:
  static constexpr int M = 0;
};
```

メンバのアクセス指定の制限があるのは非静的メンバ変数だけなので、静的メンバ変数同様にメンバ関数のアクセス指定も自由に書くことができます。

## 3. 仮想関数を持たない

仮想関数を持つということは構造体のレイアウトに仮想関数テーブルなどの動的ポリモルフィズムのための不可視のメンバが追加されることになるため、集成体ではなくなります。また、継承によって間接的に持つこともできません。

```cpp
struct interface {
  virtual int f() = 0;
};

// 集成体ではない
struct A1 {
  int n;

  virtual int g() {
    return 1;
  }
};

// 集成体ではない
struct A2 : interface {
  int n;
};
```

インターフェースクラスを継承するような場合は残念ながら集成体を活用することはできません。

## 4. `public`以外の継承をしていない

継承すること自体は問題ないのですが、集成体では`public`継承だけが許可されます。

```cpp
// 集成体ではない
struct base {
  int n;

  base() = default;
};

// 集成体ではない
struct A1 : private base {
  double d;
};

// 集成体ではない
struct A2 : protected base {
  double d;
};

// これは集成体
struct A3 : public base {
  double d;
};
```

この例からもわかるように、継承する場合は基底クラスが集成体でなくてもOKです。

\clearpage

# 集成体の特性

ここからは、構造体を集成体にすることによって得られるいくつかの性質を見ていきます。

## 集成体初期化

集成体初期化は集成体にすることによって得られる最も大きな特徴でしょう。`{}`（波かっこ）を用いた初期化構文によって初期化できるようになり、通常の`()`（丸かっこ）による初期化とは少し違った振る舞いをします。これは集成体にすることによって仮想的なコンストラクタが自動生成されていると見ることができます。

```cpp
struct aggregate {
  int n;
  double m = 2.72;  // デフォルトメンバ初期化
  std::string str;
};

// 集成体初期化
aggregate agg1 = {20, 3.14, "Aggregate"};
aggregate agg2 = {20, 3.14};  // strはデフォルトコンストラクタで初期化される（空の文字列となる）
aggregate agg3 = {20};        // mは2.72で初期化される
aggregate agg4 = {};          // nはゼロ初期化（0相当の値で初期化）される
```

集成体初期化は基本的にはこのように波かっこによって初期化します。初期化子の数が集成体のメンバの数を超えているとエラーになりますが、足りない場合はデフォルトメンバ初期化によって初期化され、それが無い場合は再帰的に`{}`で初期化されることになります。

また、明示的に`{}`によって初期化することもでき、その場合の初期化はそれぞれのメンバを`{}`で初期化したようになります（デフォルトメンバ初期化は無視されます）。ただし、`{}`さえも省略して初期化子をなしにすることはできません。

```cpp
aggregate agg1 = {20, 3.14, {}};  // strはデフォルトコンストラクタで初期化される（空の文字列となる）
aggregate agg2 = {20, {}, {}};    // mはゼロ初期化（0.0相当の値で初期化）される
aggregate agg3 = {{}, {}, {}};    // nはゼロ初期化（0相当の値で初期化）される
aggregate agg4 = {　, , };          // コンパイルエラー、{}が必要
```

このような初期化は、デフォルトコンストラクタを持つクラス型の場合はデフォルトコンストラクタを呼び出すことに対応しています。

このことと同じように、集成体に含まれるクラス型のコンストラクタを`{}`によって呼び出すことができます。

```cpp
aggregate agg1 = {20, 3.14, {"string", 3}};              // strは"string"の先頭3文字で初期化
aggregate agg2 = {20, 3.14, {"string", oreore_alloc{}}}; // strは"string"と渡されたアロケータで初期化
```

この時、`{}`で初期化されているメンバが集成体であれば集成体初期化によって初期化されます。ただ残念ながら、このときに`()`でコンストラクタ呼び出しすることはできません。それは例えば`std::string`の特定のコンストラクタが呼び出せないなどの影響があります。

また、集成体が継承をしているときは、集成体初期化の最初で基底クラスに対する初期化をを行います。もし意図せずに省略された場合はその分初期化子の対象がずれることになり、思わぬバグを生むかもしれません。

```cpp
// 集成体ではない
struct base {
  int n;

  base() = default;
  base(int m) : n(m) {}
};

struct aggregate2 : base {
  int n;
  double m = 2.72;
  std::string str;
};

aggregate2 agg1 = {{}, 10, 3.14, "str"};    // 基底クラスはデフォルトコンストラクタで初期化
aggregate2 agg2 = {{20}, 10, 3.14, "str"};  // 基底クラスはbase::base(int)のコンストラクタで初期化
aggregate2 agg3 = {20, 10, 3.14, "str"};    // 同上

aggregate2 agg4 = {10, 3.14, "str"};        // コンパイルエラー（初期化対象がずれており、この例では2番目と3番目で変換エラーが出る）
```

この3番目の例のように、集成体初期化ではネストしている型の初期化に必要な`{}`を省略することができます。

```cpp
struct A {
  int arr[5];
};

struct aggregate3 : base {
  A array;
  int n;
  std::string str;
};

aggregate3 agg1 = {{10}, {{0, 1, 2, 3, 4}}, 20, "string"};  // フル{}
aggregate3 agg2 = {{10}, { 0, 1, 2, 3, 4 }, 20, "string"};  // 1段省略
aggregate3 agg3 = { 10 ,   0, 1, 2, 3, 4  , 20, "string"};  // 全省略
aggregate3 agg4 = { {} , {}               , 20, "string"};  // {}による初期化
```

ただし、そのようなクラス型の引数が多かったりすると境界が曖昧になって読みづらくなるので`{}`は入れておいた方がいいでしょう。clangはこの場合の3番目の例の`A`の初期化（2番目の初期化子）に対してそのような警告を発します。

ここまで集成体初期化の例にはすべて`= {}`の形の初期化構文を使用してきましたが、`=`をなくして変数名に直接続ける形の初期化も可能です。これらはどちらも集成体初期化として扱われます。

```cpp
aggregate  agg1{20, 3.14, {}};
aggregate2 agg2{{}, 10, 3.14, "str"};
aggregate3 agg3{{10}, { 0, 1, 2, 3, 4 }, 20, "string"};
```

これと比較すると、`= {}`の構文は右辺で一時オブジェクトを生成して左辺にムーブのようにも見えるかもしれませんが、集成体初期化の場合はどちらの構文でも同じように直接左辺の変数とそのメンバを初期化します。

説明が前後していますが実際のところ、このような集成体初期化を問題を起こさずに行えるような型のことを集成体と呼んでいます。先程の集成体の要件はすべてこのような集成体初期化を妨げないために設けられています。そして、集成体初期化はC言語の構造体にとっては普通の初期化方法であり、その意味で集成体とはCの構造体と同じようなC++の構造体と言えます。つまるところ、集成体とはかなり普通の構造体の事です。

### 縮小変換の禁止

`{}`による集成体初期化ではその初期化に際して縮小変換（*Narrowing Conversion*）が禁止されています。これは`()`による初期化と異なっています。

縮小変換とは変換先の型が変換元の型の表現を全て受け止めきれないような変換のことで、縮小変換前後で情報の欠落が発生します。C++はCからこれを受け継ぎ、特に警告やエラーになることもなく暗黙変換の一環として各所で実行されます。特に浮動小数点型の縮小変換では精度低下が伴うので静かなバグを埋め込むことが多発しています。

- `double -> float`のような精度が落ちる浮動小数点型の変換
- 浮動小数点型と整数型の間の双方向の変換
- 整数型と整数型の間で、表現の欠落が発生する変換
    - ビット幅が小さくなる変換 : `int -> char`など
    - 符号付から符号なしへの変換 : `int -> std::size_t`など
    - 符号なしから符号付への変換で正の表現が欠落しうる変換 : `std::size_t -> short`など
- ポインタ型から`bool`への変換（C++20以降）

集成体初期化においてはこのような変換が起こる場合はコンパイルエラーとなります。

```cpp
struct narrow {
  int n;
  float f;
};

int main() {
  unsigned int un = 10;
  long double ld = 1.0;

  narrow n1 = {20, 0.1f}; // OK
  narrow n2 = {un, 0.1f}; // unsigned -> int の縮小変換、コンパイルエラ－
  narrow n3 = {20, ld};   // long double -> floatの縮小変換、コンパイルエラー
  narrow n4 = {un, ld};   // 両方、コンパイルエラー
}
```

ただし、定数式中の`{}`集成体初期化で縮小変換が発生する時、その変換に伴って情報の欠落が発生しないことが確認できる場合は一部の縮小変換が許可されます。

```cpp
struct A {
  unsigned int n;
};

int n = 10;
A a1 = {n};   // コンパイルエラー
A a2 = {10};  // OK
A a3 = {-1};  // コンパイルエラー
```

### 初期化子評価順序の規定

### 指示付初期化（*Designated Initialization*）

### 丸かっこによる集成体初期化

### 一様初期化（*Uniform Initialization*）と集成体初期化

## 構造化束縛への適合

## ボイラープレートコードの削減

先程も説明しましたが集成体初期化が可能になることによって仮想的なコンストラクタが提供されるようになるため、コンストラクタを書かなくて良くなります。また、すべてのメンバは必然的に`public`なので、ゲッター/セッターのようなものも必要なくなります。

```cpp
struct aggregate {
  int n;
  double m = 2.72;
  std::string str;
};

// ↑のクラスを普通に書くと例えば↓のようになる

class not_aggregate {
  int n;
  double m = 2.72;
  std::string str;

public:

  not_aggregate() = default;

  not_aggregate(int an, double am, std::string astr)
    : n(an)
    , m(am)
    , str(std::move(astr))
  {}

  int get_n() const {
    return n;
  }

  void set_n(int an) const {
    n = an;
  }

  // 以下略
};
```

あえて書いてみるとそれなりの量のコードを削減することができるのが分かるでしょう。

\clearpage

# 集成体進化の歴史

## C++11

## C++14

## C++17

## C++20
