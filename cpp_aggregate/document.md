---
title: C++ 集成体
author: onihusube
date: 2020/09/01
geometry:
  width: 188mm
  height: 263mm
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

この本はC++20をベースとして書かれています。基本的なところはC++17以前から変わってはいませんが、一部の仕様などはC++のバージョン毎に異なったりしています。もしかしたらお手元のコンパイラではエラーになったり挙動が異なったりするかもしれません。ご了承ください。

# 集成体（*Aggregate*）とは

集成体（*Aggregate*）とはいくつかの条件を満たした構造体（クラス）および共用体の事です（C形式の配列も集成体ですがここでは構造体だけに着目します）。とはいえ特別なものではなく、C++におけるC言語の構造体相当の構造体の事をそう呼びます。最も有名な集成体は`std::array`でしょう。`std::array`は集成体となるように実装されます。

```cpp
// 集成体の一例
struct aggregate {
  int n;
  double m;
  std::string str;
};

// 集成体初期化
aggregate agg = {20, 3.14, "Aggregate"};
std::array<int 5> arr = {1, 2, 3, 4, 5};
```

このように、集成体では集成体初期化によって仮想的なコンストラクタが提供されるため、メンバを初期化するためにコンストラクタを書く必要が無くなります。

集成体は、単にいくつかのデータをまとめたタプルの様な型やすべてのメンバがパブリックであるようなクラスに対して活用することができ、余計なコンストラクタやセッター/ゲッターといったボイラープレートコードを削減することができます。

\clearpage

# 集成体の要件

ある構造体（クラス）が集成体となるためには次の条件を満たしていなければなりません。

1. ユーザー宣言コンストラクタおよび継承コンストラクタを持たない
2. `public`ではない（非`static`）メンバ変数を持たない
3. 仮想関数を持たない
4. `public`以外の継承をしていない

これらの規則を守ってさえいれば他の事は何をしても大丈夫です。この規則を守らなくても別にコンパイルエラーになったりせず、普通のクラスと同等の扱いになるだけです。

## 1. ユーザー宣言コンストラクタおよび継承コンストラクタを持たない

これは言い換えると、あらゆるコンストラクタを宣言していないということです。コピー/ムーブコンストラクタ、`= default`や`= delete`なコンストラクタも含めて、あらゆるコンストラクタを書いてはいけません。

```cpp
// これらはどれも集成体ではない

struct A1 {
  int n;

  A(int m) : n(m) {}
};

struct A2 {
  int n;

  A() = default;
};

struct A3 {
  int n;

  A(A&&) = default;
};
```

このようなコンストラクタ宣言が一つでもあるとその構造体は集成体ではなくなります。

もう一つの継承コンストラクタというのは、継承しているときに基底クラスのコンストラクタを有効化する`using`のことで、これによって基底クラスのコンストラクが利用可能になりますが、コンストラクタが宣言されているのと等価なので集成体ではなくなります。

```cpp
struct base {
  int n;

  base() : n(0) {}

  base(int m) : n(m) {}
};

// A1は集成体ではない
struct A1 : base {
  using base::base; // コンストラクタを継承する
};

// A2は集成体
struct A2 : base {};
```

この規定があることからわかるように、集成体になるにあたっては公開継承している分には問題ないですし、基底クラスが集成体でなくてもOKです。

## 2. `public`ではないメンバ変数を持たない

これはそのままの意味です。`private`とか`protected`でメンバ変数を宣言してはいけません。ただし、この場合のメンバ変数とは非静的なメンバ変数であって、`static`メンバ変数がどこにあろうと集成体となることを妨げません。

```cpp
// これは集成体ではない
class A1 {
  int n;  // classのデフォルトアクセス指定ははprivate
};

// これも集成体ではない
struct A2 {
  int n;

protected:
  int m;
};

// これは集成体
struct A3 {
  int n;

private:
  static constexpr int M = 0;
};
```

メンバのアクセス指定の制限があるのは非静的メンバ変数だけなので、静的メンバ変数同様にメンバ関数のアクセス指定も自由に書くことができます。

## 3. 仮想関数を持たない

仮想関数を持つということは構造体のレイアウトに仮想関数テーブルなどの動的ポリモルフィズムのための不可視のメンバが追加されることになるため、集成体ではなくなります。また、継承によって間接的に持つこともできません。

```cpp
struct interface {
  virtual int f() = 0;
};

// 集成体ではない
struct A1 {
  int n;

  virtual int g() {
    return 1;
  }
};

// 集成体ではない
struct A2 : interface {
  int n;
};
```

インターフェースクラスを継承するような場合は残念ながら集成体を活用することはできません。

## 4. `public`以外の継承をしていない

継承すること自体は問題ないのですが、集成体では`public`継承だけが許可されます。

```cpp
// 集成体ではない
struct base {
  int n;

  base() = default;
};

// 集成体ではない
struct A1 : private base {
  double d;
};

// 集成体ではない
struct A2 : protected base {
  double d;
};

// これは集成体
struct A3 : public base {
  double d;
};
```

この例からもわかるように、継承する場合は基底クラスが集成体でなくてもOKです。

\clearpage

# 集成体の特性

ここからは、構造体を集成体にすることによって得られるいくつかの性質を見ていきます。

## 構造化束縛への適合

集成体にすることによって構造化束縛で自然に分解できるようになります。本来構造化束縛に適合するためには`std::tuple`と同様のタプルインターフェースを実装しなければなりませんが、集成体は言語サポートによって何もしなくても構造化束縛できます。

```cpp
struct point3d {
  double X, Y, Z;
};

point3d f() {
  return {1.0, 2.0, 3.0};
}

int main() {
  auto [x, y, z] = f();
  // x == 1.0, y == 2.0, z == 3.0
}
```

## ボイラープレートコードの削減

集成体初期化が可能になることによってコンストラクタを書かなくて良くなり、すべてのメンバは必然的に`public`なのでゲッター/セッターのようなものも必要なくなります。

```cpp
struct aggregate {
  int n;
  double m = 2.72;
  std::string str;
};

// ↑のクラスを普通に書くと例えば↓のようになる

class not_aggregate {
  int n;
  double m = 2.72;
  std::string str;

public:

  not_aggregate() = default;

  not_aggregate(int an, double am, std::string astr)
    : n(an)
    , m(am)
    , str(std::move(astr))
  {}

  int get_n() const {
    return n;
  }

  void set_n(int an) const {
    n = an;
  }

  // 以下略
};
```

あえて書いてみるとそれなりの量のコードを削減することができるのが分かるでしょう。

また、構造化束縛をする場合はタプルインターフェースを備える必要がありますが、これもそこそこの量のボイラープレートが必要になります。先程説明したように、集成体は構造化束縛にそのまま適合できるため、ここでもそれなりの量のボイラープレートを削減できます。

\clearpage

## 集成体初期化

集成体初期化は集成体にすることによって得られる最も大きな特徴でしょう。`{}`（波かっこ）を用いた初期化構文によって初期化できるようになり、通常の`()`（丸かっこ）による初期化とは少し違った振る舞いをします。これは集成体にすることによって仮想的なコンストラクタが自動生成されていると見ることができます。

```cpp
struct aggregate {
  int n;
  double m = 2.72;  // デフォルトメンバ初期化
  std::string str;
};

// 集成体初期化
aggregate agg1 = {20, 3.14, "Aggregate"};
aggregate agg2 = {20, 3.14};  // strはデフォルトコンストラクタで初期化される（空の文字列となる）
aggregate agg3 = {20};        // mは2.72で初期化される
aggregate agg4 = {};          // nはゼロ初期化（0相当の値で初期化）される
```

集成体初期化は基本的にはこのように波かっこによって初期化します。初期化子の数が集成体のメンバの数を超えているとエラーになりますが、足りない場合はデフォルトメンバ初期化によって初期化され、それが無い場合は再帰的に`{}`で初期化されることになります。

また、明示的に`{}`によって初期化することもでき、その場合の初期化はそれぞれのメンバを`{}`で初期化したようになります（デフォルトメンバ初期化は無視されます）。ただし、`{}`さえも省略して初期化子をなしにすることはできません。

```cpp
aggregate agg1 = {20, 3.14, {}};  // strはデフォルトコンストラクタで初期化される（空の文字列となる）
aggregate agg2 = {20, {}, {}};    // mはゼロ初期化（0.0相当の値で初期化）される
aggregate agg3 = {{}, {}, {}};    // nはゼロ初期化（0相当の値で初期化）される
aggregate agg4 = { , , };         // コンパイルエラー、{}が必要
```

このような初期化は、デフォルトコンストラクタを持つクラス型の場合はデフォルトコンストラクタを呼び出すことに対応しています。

このことと同じように、集成体に含まれるクラス型のコンストラクタを`{}`によって呼び出すことができます。

```cpp
aggregate agg1 = {20, 3.14, {"string", 3}};              // strは"string"の先頭3文字で初期化
aggregate agg2 = {20, 3.14, {"string", oreore_alloc{}}}; // strは"string"と渡されたアロケータで初期化
```

この時、`{}`で初期化されているメンバが集成体であれば集成体初期化によって初期化されます。ただ残念ながら、このときに`()`でコンストラクタ呼び出しすることはできません。それは例えば`std::string`の特定のコンストラクタが呼び出せないなどの影響があります。

また、集成体が継承をしているときは、集成体初期化の最初で基底クラスに対する初期化をを行います。もし意図せずに省略された場合はその分初期化子の対象がずれることになり、思わぬバグを生むかもしれません。

```cpp
// 集成体ではない
struct base {
  int n;

  base() = default;
  base(int m) : n(m) {}
};

struct aggregate2 : base {
  int n;
  double m = 2.72;
  std::string str;
};

aggregate2 agg1 = {{}, 10, 3.14, "str"};    // 基底クラスはデフォルトコンストラクタで初期化
aggregate2 agg2 = {{20}, 10, 3.14, "str"};  // 基底クラスはbase::base(int)のコンストラクタで初期化
aggregate2 agg3 = {20, 10, 3.14, "str"};    // 同上

aggregate2 agg4 = {10, 3.14, "str"};        // コンパイルエラー（初期化対象がずれており、この例では2番目と3番目で変換エラーが出る）
```

この3番目の例のように、集成体初期化ではネストしている型の初期化に必要な`{}`を省略することができます。

```cpp
struct A {
  int arr[5];
};

struct aggregate3 : base {
  A array;
  int n;
  std::string str;
};

aggregate3 agg1 = {{10}, {{0, 1, 2, 3, 4}}, 20, "string"};  // フル{}
aggregate3 agg2 = {{10}, { 0, 1, 2, 3, 4 }, 20, "string"};  // 1段省略
aggregate3 agg3 = { 10 ,   0, 1, 2, 3, 4  , 20, "string"};  // 全省略
aggregate3 agg4 = { {} , {}               , 20, "string"};  // {}による初期化
```

ただし、そのようなクラス型の引数が多かったりすると境界が曖昧になって読みづらくなるので`{}`は入れておいた方がいいでしょう。clangはこの場合の3番目の例の`A`の初期化（2番目の初期化子）に対してそのような警告を発します。

ここまで集成体初期化の例にはすべて`= {}`の形の初期化構文を使用してきましたが、`=`をなくして変数名に直接続ける形の初期化も可能です。これらはどちらも集成体初期化として扱われます。

```cpp
aggregate  agg1{20, 3.14, {}};
aggregate2 agg2{{}, 10, 3.14, "str"};
aggregate3 agg3{{10}, { 0, 1, 2, 3, 4 }, 20, "string"};
```

これと比較すると、`= {}`の構文は右辺で一時オブジェクトを生成して左辺にムーブのようにも見えるかもしれませんが、集成体初期化の場合はどちらの構文でも同じように直接左辺の変数とそのメンバを初期化します。

説明が前後していますが実際のところ、このような集成体初期化を問題を起こさずに行えるような型のことを集成体と呼んでいます。先程の集成体の要件はすべてこのような集成体初期化を妨げないために設けられています。そして、集成体初期化はC言語の構造体にとっては普通の初期化方法であり、その意味で集成体とはCの構造体と同じようなC++の構造体と言えます。つまるところ、集成体とはかなり普通の構造体の事です。

### 縮小変換の禁止

`{}`による集成体初期化ではその初期化に際して縮小変換（*Narrowing Conversion*）が禁止されています。これは`()`による初期化と異なっています。

縮小変換とは変換先の型が変換元の型の表現を全て受け止めきれないような変換のことで、縮小変換前後で情報の欠落が発生します。C++はCからこれを受け継ぎ、特に警告やエラーになることもなく暗黙変換の一環として各所で実行されます。特に浮動小数点型の縮小変換では精度低下が伴うので静かなバグを埋め込むことが多発しがちです。

縮小変換とは以下の様な変換です。

- `double -> float`のような精度が落ちる浮動小数点型の変換
- 浮動小数点型と整数型の間の双方向の変換
- 整数型と整数型の間で、表現の欠落が発生する変換
    - ビット幅が小さくなる変換 : `int -> char`など
    - 符号付から符号なしへの変換 : `int -> std::size_t`など
    - 符号なしから符号付への変換で正の表現が欠落しうる変換 : `std::size_t -> short`など
- ポインタ型から`bool`への変換（C++20以降）

集成体初期化においてはこのような変換が起こる場合はコンパイルエラーとなります。

```cpp
struct narrow {
  int n;
  float f;
};

int main() {
  unsigned int un = 10;
  long double ld = 1.0;

  narrow n1 = {20, 0.1f}; // OK
  narrow n2 = {un, 0.1f}; // unsigned -> int の縮小変換、コンパイルエラ－
  narrow n3 = {20, ld};   // long double -> floatの縮小変換、コンパイルエラー
  narrow n4 = {un, ld};   // 両方、コンパイルエラー
}
```

ただし、定数式中の`{}`集成体初期化で縮小変換が発生する時、その変換に伴って情報の欠落が発生しないことが確認できる場合は一部の縮小変換が許可されます。

```cpp
struct A {
  unsigned int n;
};

int n = 10;
A a1 = {n};   // コンパイルエラー
A a2 = {10};  // OK
A a3 = {-1};  // コンパイルエラー
```

このように、縮小変換が禁止されていることによってより安全な初期化が出来るようになっています。  
C++（コミュニティ、委員会）の一つの見解（そして後悔）として、C言語から暗黙変換を受けつくべきではなかったというのがあります。この思想はC++にとどまらないようで、多くの後継の言語は暗黙変換を型システムから排除しています。この集成体初期化がそうであるように、C++11以降に追加される機能の多くはその思想に基づいて縮小変換を含めた暗黙変換を嫌う傾向にあります。ただ、暗黙変換は既にC++コードの多くの場所で定着しているため禁止されていることはユーザーから見ると不便であり、また意味不明なコンパイルエラーが発生することにもなります。そのため、単純に暗黙変換を排除することはできず、これからも付き合っていく必要がありそうです・・・

### 初期化子評価順序の規定

集成体初期化の`()`と異なるもう一つの点は、`{}`内の初期化式の評価順序が規定されていることです。

```cpp
struct aggregate {
  int a, b, c, d;
};

struct not_aggregate {
  int a, b, c, d;

  not_aggregate(int n1, int n2, int n3, int n4)
    : a(n1), b(n2), c(n3), d(n4)
  {}
};

int main() {
  int i = 0;

  aggregate agg = {++i, ++i, ++i, ++i}; // 評価順序は左から右と規定される
  // agg = {1, 2, 3, 4}

  i = 0;

  not_aggregate na(++i, ++i, ++i, ++i); // 評価順序は未規定
  // na = {4, 4, 4, 4} GCC 10.1
  // na = {1, 2, 3, 4} Clang 10.0.0
  // na = {4, 3, 2, 1} MSVC 2019 16.7 Preview 6.0
}
```

初期化式とはこの様に初期化子として指定されている式の事を言います。その評価順序は、同じ変数に対して変更を加えるような式が一つの初期化構文内に複数あるとき問題になります。`()`だとそれぞれの式の実行順序が決まっていませんが、`{}`の場合はその初期化子の順番通りに左から右へ実行しつつ初期化すると明確に決まっています。

### 指示付初期化（*Designated Initialization*）

指示付初期化とは、集成体初期化時にその集成体のメンバ名を指定する形で初期化する構文の事です。C言語ではC99から可能でしたが、C++にはC++20から制限付きで導入されました。

```cpp
struct point3d {
  double X, Y, Z;
};

int main() {
  // この二つの初期化構文は同じ意味
  point3d vec1 = { .X = 2.0, .Y = 3.0, .Z = 1.0};
  point3d vec2 = { 2.0, 3.0, 1.0};
}
```

このような名前指定（`.X`や`.Y`）の事を指示子と呼びます。指示子を指定できること以外は普通の集成体初期化と同じ効果（初期化式の評価準や縮小変換の禁止など）を持ちます。

ただしいくつか制約があり、ほとんど普通の集成体初期化でメンバ名を指定できるようになったくらいのことしかできません。

1. 指示子の順番はメンバの宣言順
2. 指示子を書くならば全てに指示子による初期化が必要
      - 指示子のあるなしが混在できない
3. 指示子はネストできない

```cpp
struct nest {
  int n;
  point3d p;
  int m;
};

int main() {
  // 1. 指示子の順番はメンバの順番通りでなければならない
  point3d v1 = { .X = 1.0, .Z = 2.0, .Y = 1.0}; // エラー
  point3d v2 = { .X = 1.0, .Y = 1.0, .Z = 2.0}; // OK

  // 2. 指示子はあるかないかのどちらか
  point3d v3 = { 1.0, .Y = 2.0, 3.0};       // エラー
  point3d v3 = { .X = 1.0, .Y = 2.0, 3.0};  // エラー

  // 3. ネストした集成体に対しては{}をネストさせる
  nest n1 = { .n = 1, .p.X = 1.0, .p.Y = 1.0, .p.Z = 1.0, .m = 2};    // エラー
  nest n1 = { .n = 1, .p = { .X = 1.0, .Y = 1.0, .Z = 1.0 }, .m = 2}; // OK
}
```

この3番目の例を見るとひらめくかもしれませんが、指示子による初期化では`{}`初期化を使用できます。また、末尾のメンバから指示子を省略することもでき、その場合は`{}`を指定したかの様に初期化されます。

```cpp
int main() {
  // {}を使った初期化ができる
  point3d v1 = { .X = {1.0}, .Y{1.0}, .Z{} };

  // 省略した要素は{}（この場合は0.0）で初期化される
  point3d v2 = { .X = 1.0, .Y = 1.0 };
  point3d v3 = { .X = 1.0 };

  // ただし前にある要素の初期化子を省略できない
  point3d v3 = { .Y = 1.0 };            // エラー
  point3d v3 = { .X = 1.0, .Z = 1.0 };  // エラー
}
```

このような指示付初期化は初期化するメンバ名を明確にすることによって初期化指定の間違いを発見しやすくする効果があり（間違えるとコンパイルエラーになる）、大量のメンバを持つ構造体の初期化を読みやすくできたりします。他にも、共用体の初期化時に初期化するメンバを指定して初期化できたり、応用すると簡単な名前付き引数を実現できたりします。

```cpp
union U {
  int n;
  double d;
};

int main() {
  U u1 = {10};          // nを10で初期化
  U u2 = { .n = 10 };   // 同上
  U u3 = { .d = 3.14 }; // dを3.14で初期化

  U u4 = {3.14};                // エラー、縮小変換
  U u5 = { .n = 1, .d = 2.72 }; // エラー、初期化子が多い
}
```

### 丸かっこによる集成体初期化

ここまでのように集成体初期化は`{}`によって行われるものでしたが、C++20より`()`でも行えるようになります。ただし、変数名に直接続く形しか許可されず、間に`=`が入る形は許可されません。

```cpp
struct aggregate {
  int n;
  double m = 2.72;
  std::string str;
};

int main() {
  aggregate a1{10, 2.72, "braces"};
  aggregate a2(10, 2.72, "parentheses");

  // これはだめ
  aggregate a3 = (10, 2.72, "parentheses");
}
```

ただし、いくつか`{}`による集成体初期化と異なるところがあります。

1. 縮小変換が許可される
2. ネストする波かっこが省略できない
3. ネストする場合に丸かっこを使えない
4. 指示付初期化できない
5. 空の`()`を使えない

```cpp
struct narrow {
  int n;
  float f;
};

struct wrap {
  narrow n;
  int m;
};


int main() {
  unsigned int n = 10;
  long double d = 1.0;

  // 1. 縮小変換の許可
  narrow n1{10u, 1.0l}; // 2つともエラー
  narrow n2(10u, 1.0l); // OK

  // 2. 波かっこ省略できない
  wrap w1{10, 1.0f, 20};    // OK
  wrap w2(10, 1.0f, 20);    // エラー
  wrap w3({10, 1.0f}, 20);  // OK

  // 3. ネストして丸かっこを使えない
  wrap w4((10, 1.0f), 20);  // エラー

  // 4. 指示付初期化できない
  narrow n3(.n = 10, .f = 1.0f);        // エラー
  wrap w5({ .n = 10, .f = 1.0f}, 20);   // OK

  // 5. 空にすると関数宣言とあいまいになる
  narrow n4{};  // OK、変数宣言
  narrow n5();  // エラーにはならないが関数宣言として処理されている
}
```

これらの制約の大部分は`()`による集成体初期化がコンストラクタ呼び出しの意味論を踏襲するように設計されていることから来ています。

このような`()`による集成体初期化は集成体をより通常のクラスに近づけるもので、主に、標準コンテナなどが備える`emplace`関数で集成体を初期化できなかった問題を解決するものです。

```cpp
int main() {
  std::vector<aggregate> v{};

  v.emplace_back(10, 3.14, "emplace");            // C++17まではエラー
  v.emplace_back(aggregate{10, 3.14, "emplace"}); // C++17でもOK、ムーブ構築
}
```

`emplace`系関数はコンストラクタの引数を受け取ってその内部でコンストラクタを呼び出して構築を行うもので、（コンテナ等に対する）直接構築などとも呼ばれます。その実装は共通して、内部で構築対象領域へ`placement new`することで構築します。

```cpp
// 単純なemplace関数の実装例
template<typename... Args>
T& emplace(Args&&... args) {
  // 構築したい領域をstorageとする
  T* p = new(&storage) T(std::forward<Args>(args)...); // ここで()を使っているために集成体初期化が行われない

  // こうすると集成体初期化は行われるが、多くのクラス型で問題が起こる
  T* p = new(&storage) T{std::forward<Args>(args)...};

  return *p;
}
```

ここでの`new`による構築時に`T()`としていることによって、`T`が集成体である場合に集成体初期化が行われません（コピー/ムーブコンストラクタは呼ばれる）。そこを`{}`に変えてしまえば集成体初期化は行われますが、`{}`と`()`の性質の違いから後方互換性を破壊してしまいます。`()`による集成体初期化はこのような場合にわざわざ集成体にコンストラクタを書かいたり、ムーブ構築に切り替えたりしなくてもよくするために導入されました。

実際のところ、`()`による初期化が必要となるのはこのようなライブラリの深部においてだけであり、普通に使う分には常に`{}`を使うべきです。

### 集成体初期化と一様初期化（*Uniform Initialization*）

C++11から一様初期化構文が導入され、非集成体のクラスの変数でも`{}`によってコンストラクを呼び出して初期化できるようになりました。この一様初期化においても縮小変換の禁止や初期化式評価順序の規定などの集成体初期化の性質を利用することができます。ただ、指示付初期化は行えません。

一様初期化は配列や集成体に対して可能だった`{}`による初期化をクラス型に対して拡張することで、初期化構文を統一することを目指したものでした。しかし、`{}`と合わせた縮小変換の禁止によって`{}`を使うと謎のエラーが発生したり、`std::initializer_list`をとるコンストラクタを持つ型に対する`{}`の初期化は最優先で`std::initializer_list`をとるコンストラクタを呼び出してしまうなどの絶妙に使いづらくわかりづらいところがあり、実際には`{}`による初期化構文の統一は果たせなかったどころか、失敗機能扱いされつつあります・・・

なお、一様初期化構文において問題となることは集成体初期化では問題にならないので集成体初期化で`{}`を嫌う理由はありません。

\clearpage

# 特殊メンバ関数

集成体ではコンストラクタ宣言を行えないので、クラスの特殊メンバ関数はコンパイラによって自動的に定義される使用可能になります。

## デフォルトコンストラクタ

空のリスト（`{}`）が実質的にデフォルトコンストラクタと同じ働きをします。空のリストで初期化すると、集成体のメンバのうちデフォルトメンバ初期化されているものはそれによって初期化され、基底クラスおよび残りのメンバは再帰的に空のリスト（`{}`）で初期化されます（すなわち、集成体は集成体初期化され、そうでないものは値初期されます）。

従って、メンバの中にデフォルトメンバ初期化されておらずデフォルトコンストラクタを持たないような型があると、空のリストによる初期化はコンパイルエラーとなります。

```cpp
struct not_def_init {
  int n = 0;
  not_def_init() = delete;
  not_def_init(int an) : n(an) {}
};

struct A1 {
  int n = 10;
  double d;
};

struct A2 {
  int n;
  not_def_init ni;  // デフォルトコンストラクタを持たない
};

int main() {
  A1 a1 = {}; // n == 10, d == 0.0
  A2 a2 = {}; // エラー
}
```

## コピー/ムーブコンストラクタ

コピー/ムーブコンストラクタは通常のクラス型で一切宣言しない時と同様に利用可能になります。すなわち、メンバ毎にその型のコピー/ムーブコンストラクタを呼び出していく実装がなされます。従って、メンバの中にムーブコンストラクタを持たない型がある場合はその集成体のムーブコンストラクタは暗黙に`delete`され、コピーコンストラクタを持たない型がある場合は同様にコピーコンストラクタは暗黙に`delete`されます。

C++17までは`default/delete`宣言によってある程度これを制御できたのですが、現在はあらゆるコンストラクタの宣言が禁止されているため明示的に制御する方法はありません。

```cpp
struct not_move {
  not_move() = default;
  not_move(const not_move&) = delete;
};

struct A1 {
  std::unique_ptr<int> up;  // コピー不可
};

struct A2 {
  not_move nc;  // コピー・ムーブ不可
};

int main() {
  A1 a1 = {};
  A2 a2 = {};

  A1 c1 = {a1};             // エラー
  A1 m1 = {std::move(a1)};  // OK

  A2 c2 = {a2};             // エラー
  A2 m2 = {std::move(a2)};  // エラー
}
```

## コピー/ムーブ代入演算子

コピー/ムーブ代入演算子はコピー/ムーブコンストラクタと同様に利用可能になります。

こちらは宣言してあっても集成体となるかどうかに一切影響を与えないので、自前で実装することもできます。

（サンプルコードは先程のコピー/ムーブコンストラクタのものとほぼ同じなので省略します）

# 集成体と参照型メンバ

集成体のメンバ変数に制約はなく、どんな型でもメンバとなることができます。`const/volatile`、ポインタ型、そして参照型もです。集成体で参照型をメンバとする場合、非集成体と比較して明らかにメリットが一つあります。

まず、参照メンバをもつ普通のクラス型を書いてみます。

```cpp
class cont_ref {
  int& m_ref;

public:
  cont_ref(int n) // ??
   : m_ref(n)
  {}

  operator int() const {
    return m_ref;
  }
};

int main() {
  int n = 10;

  cont_ref cr{n};

  n = 20;

  std::cout << int(cr); // Undefined Behavior・・・
}
```

はい、普通です。一箇所致命的なミスをしている点を除けば。

コンストラクタ引数が参照型になっていません。こうなっていると、コンストラクタ引数のローカル変数でクラスメンバの参照を初期化することになるので、コンストラクタ呼び出しの終了後にメンバの参照はダングリング参照となりそのアクセスは未定義動作となります。たった一文字忘れただけなのに・・・  
もちろん、局所的に見ればこれは何ら問題の無いコードなのでコンパイルエラーにはなりません（clangだけは一応警告してくれるようです）。

上記クラスのコンストラクタは正しくは次のように書かなければなりません。

```cpp
class cont_ref {
  int& m_ref;

public:
  cont_ref(int& n)  // &の1文字が重要！
   : m_ref(n)
  {}
};
```

これによって意図通りにコンストラクタに渡された別の変数の参照をメンバとして保持できるようになります。

ではこれを集成体で書くとどうなるでしょうか？

```cpp
struct cont_ref {
  int& m_ref;
};

int main() {
  int n = 10;

  cont_ref cr = {n};

  n = 20;

  std::cout << cr.m_ref; // OK、20
}
```

コンストラクタを書く必要がないのでとてもすっきりします。そして、間違えようがありません。この様に、参照型メンバを扱う際は集成体にすると省コードかつ安全に書くことができます。

ちなみに、参照型メンバを持つ時はデフォルト構築とあらゆる代入操作は出来ません。コピーとムーブコンストラクタは他のメンバが利用可能であれば利用可能となります。ただ、この振る舞いはクラス型の場合もほぼ同様です。

```cpp
int main() {
  cont_ref cr1{}; // エラー、参照型メンバは必ず初期化されなければならない

  int n = 10;

  cont_ref cr2{n};
  cont_ref cr3{cr2};  // OK、コピー（ムーブ）コンストラクタは利用可能

  cr3 = cr2;  // エラー、コピー（ムーブ）代入演算子は利用不可
}
```

このことはクラス型で参照型メンバを持つ時にコンストラクや代入演算子を実装することを考えてみると分かりやすいです。初期化後の参照型変数に対するあらゆる操作は参照先の変数に対する操作になるため、参照そのものをコピーしたりできないためコピー/ムーブ代入演算子を実装すことが出来ません。一方、コンストラクタの場合はコンストラクタ初期化子リストで参照の初期化が行えるため、コピー/ムーブコンストラクタを実装することができます。

## 一時オブジェクトの寿命延長

集成体で参照型メンバを持ち集成体初期化を行う時、初期化子の一時オブジェクトの寿命を延長させることができます。とはいっても、参照型とはこの場合`const`左辺値参照と右辺値参照メンバが対象です。

```cpp
struct lifetime_extender {
  std::string&& r_ref;
  const std::string& cl_ref;
};

int main() {
  lifetime_extender le = {std::string{}, "rvalue"}; // OK

  // どちらの参照先も生存期間内であり、安全に参照できる
  std::cout << le.r_ref << '\n'
            << le.cl_ref << '\n';
}
```

この`le`の初期化式にある二つの`std::string`オブジェクトは右辺値であり、本来その寿命はその一連の式の終端、すなわち最初のセミコロン`;`までです。しかし、右辺値参照型（`std::string&&`）と`const`左辺値参照型（`const std::string&`）のメンバで受けているため、それらの参照に束縛されることでその寿命が延長され初期化後も安全に参照することができます。

このことは普通に変数宣言をして初期化した時の規則と同じです。むしろ、同じことが集成体初期化という仮想的なコンストラクタを通しても起こるという事です。

```cpp
int main() {
  // 共にrvalueの寿命が延長される
  std::string&& r_ref = std::string{};
  const std::string& = "rvalue";
}
```

上記の右辺値は、正確には値カテゴリという規格用語で*prvalue*と呼ばれるカテゴリの状態にあります。*pravlue*の右辺値が右辺値参照あるいは`const`左辺値参照を初期化したときに限って、その参照は*prvalue*なオブジェクトを実体化した*lvalue*に束縛され寿命が延長されます。  
ところで右辺値にはもう一つ*xvalue*というカテゴリがあります。*xvalue*は`std::move`によって右辺値参照にキャストされた左辺値（*lvalue*）の事です。*xvalue*で上記のような参照を初期化してもコンパイルは通りますが、所有権が移行しないので寿命は元のオブジェクト次第となります。

```cpp
int main() {
  // prvalueからの初期化
  lifetime_extender le = {std::string{}, "rvalue"};

  // lvalueオブジェクトを動的構築
  std::string* str1 = new std::string{};
  std::string* str2 = new std::string{"lvalue"};
    
  // xvalueから初期化
  lifetime_extender le2 = {std::move(*str1), std::move(*str2)};

  // 元のオブジェクトを殺す
  delete str1;
  delete str2;

  // Undefined Behavior...
  std::cout << le2.r_ref << '\n'
            << le2.cl_ref << '\n';
}
```

これはかなり恣意的なコードですが、この様なことがライブラリの中に隠れているときなどに思わぬ罠を踏むかもしれません。集成体の参照メンバで寿命延長を狙う時は*prvalue*を意識しましょう。

集成体の右辺値参照メンバというのはまず使わないでしょうが`const`左辺値参照メンバはたまに使うかもしれません。そして、その参照を*prvalue*で初期化するとしたらおそらく関数の戻り値で直接初期化する時ではないかと思います。

```cpp
// prvalueを返す関数
std::string f();

// xvalueを返す関数
std::string&& g();

struct str_cref {
  const std::string& str;
};

int main() {
  str_cref sc1 = {f()}; // OK、安全
  str_cref sc2 = {g()}; // OK、もしかしたら・・・
}
```

この様な場合にこれらのこまごました事を頭の片隅に置いておくと何か役に立たないでもないかもしれません（というか*xvalue*を返す関数なんて作るべきではありません）。

### `()`・・・

# 集成体進化の歴史

## C++98/03それ以前

このあたりの仕様は仕様書が公開されていなかったりと不明なところが多いですが、ほとんどC言語の構造体そのままだったはずで、集成体初期化は最初から可能です。

このころの集成体の仕様は次のようでした。そしてこれに沿っておけば全てのバージョンのC++で集成体となることができます。

- ユーザー宣言のコンストラクタを持たない
- 非`public`なメンバ変数を持たない
- 仮想関数を持たない
- 継承していない

継承が禁止されている以外はC++20とほぼ変わりありません。

## C++11

- 集成体の要件
    - コンストラクタ宣言の許可
- 言語機能
    - 縮小変換の禁止
    - 初期化式評価順序の規定

## C++14

- 集成体の要件
    - デフォルトメンバ初期化の許可
- 言語機能
    - ネストした波かっこ省略の許可

## C++17

- 集成体の要件
    - 公開継承の許可
        - それに伴って、基底クラスを含めた集成体初期化の許可
    - 一部のコンストラクタ宣言の禁止
- 言語機能
    - 構造化束縛
    - クラステンプレートの実引数推定
      - ただし、推論ガイドが必要

## C++20

- 集成体の要件
    - あらゆるコンストラクタ宣言の禁止
- 言語機能
    - 指示付初期化
    - `()`による集成体初期化
    - クラステンプレートの実引数推定への適合（推論ガイドなしで推論する）

\clearpage

# 謝辞

　本書を執筆するに当たっては以下のサイトをとても参照しました。サイト管理者及び編集者・執筆者の方々に厚く御礼申し上げます。

- cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0)
- cppmap(https://cppmap.github.io/ : ライセンスはCC0 パブリックドメイン)
- yohhoyの日記（https://yohhoy.hatenadiary.jp）
    - Designated Initialization @ C++ : https://yohhoy.hatenadiary.jp/entry/20170820/p1
- C++11 Universal Initialization は、いつでも使うべきなのか - Qita  
  (https://qiita.com/h2suzuki/items/d033679afde821d04af8)