---
documentclass: bxjsarticle
---
\clearpage

# 標準的インターフェース

## 標準的インターフェースとは

この本でのインターフェスとは、ある共通の意味を持つようなメンバ関数であるとか、ある目的のために使用される特定のメンバ関数であるとか、そう言ったものです。動的ポリモルフィズムのために継承して利用するインターフェースクラス、という狭い意味のインターフェースではありません。

JavaやC#などのインターフェースクラスを利用した動的ポリモルフィズムでは、あるインターフェースを継承したクラスは必ずそのインターフェースを備えていることが分かり、逆に基底となっているインターフェースクラスを通してそのような限定的なインターフェースだけから異なる複数のクラスを統一的に扱います。これは、インターフェースクラスを継承させることによってクラスはそのインターフェースを備えていることを表明し、また、そのインターフェースクラスから利用することによって特定のインターフェースを備えている型だけを受け入れるように制約をかけている、と見ることが出来ます。

同じことはC++でも可能です。しかし、C++ではそのようなインターフェースクラスによる表明と制約を用いることは少なく、主としてテンプレートによるダックタイピングを多用します。この場合、ある型があるインターフェースを備えていることを表明する手段も、テンプレートな処理において入力される型に必要となるインターフェースを制約する手段もありません。ただし、C++20以降はコンセプトを用いることで後者だけは可能になりました。  
このことは、インターフェースクラスによる動的ポリモルフィズムに対して静的ポリモルフィズムと呼ばれます。

C++標準ライブラリだけを見ても、このように暗黙的に使用されているインターフェースがいくつもあります。本書ではこのことを「標準的インターフェース」と呼んでいます。また、標準ライブラリに新しいものが追加される際にもこれを意識した上でインターフェースが決定されています。

## 標準的インターフェースを利用するメリット

この標準的インターフェースを利用することで次のような利点を得ることが出来ます。

1. 変更に強いプログラムを書くことができる
2. 標準もしくは外部ライブラリで用意されている機構に意識せずともアダプトできる
3. テンプレートな処理において受け入れ可能な型の門戸を広げられる
4. 関数の命名で悩まずにすみ、利用者にとっても自然な名前を選択できる

標準的インターフェースはある程度C++を書いていれば意識せずともなんとなく身についており、そうしたC++プログラマが書いたライブラリは自然と標準的インターフェースを意識したものになります。それを知っておけば、そのようなライブラリをあまり迷わずに使用でき、また、利用されやすいライブラリを書くことができるでしょう。そして、標準的インターフェースに基づいた世界でならばそれらライブラリの相互利用さえも自然に行うことができます。

本書は、この「なんとなく」な部分を明示的に探訪したものです。

ただし、何でもかんでもこの標準的インターフェースに合わせれば良いというものではありません。これもまた暗黙的な了解によるのですが、それぞれのインターフェースにはその意味論が確かに存在しています。あるインターフェースを選択した時は、その意味論に沿った処理を行い結果を返さなければなりません。これは、よく演算子オーバーロードで例に挙げられる、「`operator+()`を不適切にオーバーロードすれば`a + b`で引き算を行うことができる（もちろん、やらないことが推奨される）」というお話に通じるものがあります。

本書では、このようなインターフェースの意味論についても説明をしてあるつもりです。

## 標準的インターフェースへアダプトする、ということ

アダプト（適合）するとは、有るインターフェースを要求する処理や機構などに対して、自作の型などをそのインターフェースを備えることで利用可能にする、というような意味です。  
例えば、自作のコンテナクラスに対してそのイテレータを返す`begin(), end()`メンバ関数を用意しておけば、そのコンテナクラスのオブジェクトで範囲`for`文が利用可能になります（この事を、範囲`for`文にアダプトすると言う事ができます）。

標準的インターフェースにアダプトしておくことで、現在利用可能なこうした機構や将来利用可能になるかもしれない機構に対して意識せずにアダプトしておくことが出来ます。これは特に、自作のライブラリを提供する際にその利用のし易さに直結するでしょう。  
例えば、`begin(), end()`メンバ関数とイテレータによる要素列挙処理はC++03より以前からありましたが、範囲`for`文が使用可能になったのはC++11以降です。しかし、従来の列挙処理を利用していた型はなんの変更も必要とせず、そのまま範囲`for`文で利用する事が出来ました。

このことは逆に考えれば、あるインターフェースにアダプトしている型はそのインターフェースだけから統一的に（型の詳細を意識せずに）利用することができる、ということです。すなわち、そのような処理ではインターフェースが利用可能である限り入力となる型を自由に取り替えることできます。そのような処理は入力となる型の変更に対して頑健になるでしょう。

このような標準的インターフェースを知っておけば、C++に対する理解を一段と深めることが出来、より良いプログラムを書くことができるようになるでしょう。

\clearpage

# イテレータインターフェース

C++STLの柱でもあり、おそらく最も自然に出会うのがこのイテレータインターフェースではないかと思います。これを備えておくことで、STLが用意するイテレータを利用するアルゴリズムなどをそのまま利用可能になります。また、範囲`for`文やC++20以降のrangeライブラリなども利用可能になります。

## イテレート可能な型のインターフェース

イテレート可能な型というのは例えば`std::vector`のような、イテレータによってその要素を列挙することのできる型のことです。STLでは、イテレータを介すことでコンテナとアルゴリズムをお互いの実装詳細から分離し、なおかつコンテナからイテレータを引き出す操作は共通化されているため、あるアルゴリズムを使用する際にコンテナの詳細をほとんど意識する必要がなくなるようになっています。

イテレート可能な型というのは標準ライブラリに多数存在するコンテナのようにわかりやすく列挙可能な型だけにとどまらず、何かしらの要素の列を抱えていて、それをある順番で1つづつ走査する、という操作が可能な任意の型を指します。そして、そのような型のイテレータインターフェースとは、その要素列を参照するイテレータの取り出し口となるものです。  
標準ライブラリの変わったところでは`std::filesystem`の`(recursive_)directory_iterator`、`std::regex`の`regex_iterator`や`istream, ostream`に対する入出力ストリームイテレータがあります。特に、列挙する全ての要素は必ずしもイテレータを取り出した時点で決定していなくても構わず、時間軸方向にランダムに到着しても良いのです。純粋に列挙可能かどうかに注目すべきです。

### `begin(), end()`

#### `cbegin(), cend()`

### イテレータ特性

### あるいは、rangeインターフェース

## イテレータ型のインターフェース

イテレータ型というのは、イテレータそのものの型のことです。せっかくイテレータという概念でアルゴリズムとコンテナを分離しているのに、イテレータ型によって操作が異なってしまうと抽象化の意味がありません。そのため、C++で利用されるイテレータのインターフェースは統一されています。

### forward iterator

#### `operator++()`

#### `operator*()`

#### `operator!=()`

#### コピー可能

### bidirectional iterator

#### `operator--()`

### random access iterator

#### `operator+=()`

#### `operator-=()`

### 全イテレータ共通の型インターフェース

# コンテナインターフェース

# 文字列インターフェース

# タプルインターフェース

タプルインターフェースを備えている型はtuple-likeな型と呼ばれます。`std::tuple`と同じように扱えると言う意味合いです。タプルインターフェースを備えておくことで、`std::apply()`や`std::make_from_tuple()`、そして何より構造化束縛へアダプトすることが出来ます。

## `std::tuple_size`

## `std::tuple_element`

## `std::get()`

# 関数呼び出しインターフェース

# `swap`インターフェース

# メタ関数のインターフェース