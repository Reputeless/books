---
title: C++20 Modules
author: onihusube
date: 2020/01/05
geometry:
  width: 154cm
  height: 216cm
  margin: 1in
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

## 本書の内容について

　本書ではC++20のモジュール仕様について、規格書の文面から読み取ることのできる理論的な部分を解説しています。従って、規格書では触れられていないビルドについてや`.dll, .lib, .so, .a`などの特殊な翻訳単位については触れていません。また、どう使うかよりはどういうものかのような理論的な側面を追求しているので、必ずしも実使用に当たって参考になるものではないかもしれません。なお、本書は以前に私が公開したブログ記事に加筆訂正を行ったものです。

　本書執筆時点では完全にモジュールを実装した処理系は存在していないため、本書の内容は実装に裏打ちされたものではなく、あくまで規格書から読み取った理論的なものにとどまります。その解釈にはおそらくいくつか間違いがあるかと思われます、ご了承ください。

　また、紙面の都合から下記の知っておいた方が良いと思われるトピックについては解説していません。分からない単語や概念に出くわしたら適宜調べてみることをお勧めします。

- 翻訳単位
- ヘッダファイルと`#include`
- 分割コンパイル
- 翻訳単位越え
- リンケージ
- テンプレートのインスタンス化
- One Difinition Rule (ODR)とその例外
- 3種類の名前探索
- 宣言と定義
- `inline`

## モジュールとは？

　モジュールとは、簡単に言えば従来のヘッダファイルとそのインクルードによるライブラリの導入を置き換えるシステムです。外部ライブラリの導入をモジュールのインポートによって行い、自作ライブラリでは公開したいものだけをエクスポートすることによって、ライブラリを使用・作成します。他の言語ではパッケージとかクレートとか呼ばれているものに相当し、より効率的なプログラムの分割・結合を可能にする仕組みです。

```cpp
// モジュールによるHello Worldの例
import <iostream>

int main() {
  std::cout << "Hello World!" << std::endl;
}
```

　現在（C++17までの）のC++にはこのような仕組みはなく、ライブラリの使用・配布はもっぱらビルド済みバイナリとヘッダーファイルの組み合わせや、ヘッダオンリーライブラリによって行われています。それらライブラリの使用時は、ライブラリの指定するヘッダーファイルを使用したい翻訳単位でインクルードすることによってライブラリのインターフェースにアクセスできるようにします。

　しかし、インクルードはC言語より引き継いだ古式ゆかしいシステムで、その実態はファイルのコピーアンドペーストであり、それにはいくつかの問題があります。

- 公開するものとしないものを選べない
    - 特に、マクロは名前空間を持たないので、一方的にばら撒かれる
- 翻訳単位ごとに同じヘッダをインクルードしていると、無駄にビルド時間が増大する
    - ヘッダオンリーライブラリにおいて顕著
- 思わぬ多重定義によるODR違反を引き起こしやすい
- ヘッダファイルと実装が別れている場合、それらが一致せずに未定義動作に陥る可能性がある

　もちろんインクルードにもメリットや便利なところもあるのですが、ライブラリの作成・配布という観点からは適切な仕組みであるとは言えません。他の言語はより高級なライブラリ管理のシステム（モジュールシステムだけではなく、パッケージマネージャも含めて）を持っており、C++にも渇望された結果、C++20にてモジュールが導入されるに至りました。

　上記で挙げたような問題はモジュールにおいては起こらないか、軽減されています。

## 言葉の前方宣言

　モジュールの説明ではどうしてもいくつか特有の言葉を導入しなければならず、しかもそれが前後しがちなので、事前に簡単かつ順番に言葉を定義しておきます。

一部の言葉は後で詳細に説明されます。

### モジュール宣言（*module decralation*）

　ある翻訳単位をモジュールを記述するものとして表明する宣言文。`export module modulename;`もしくは`module modulename;`のような宣言。

### モジュール単位（*module unit*）

　モジュール宣言を含む翻訳単位。

### モジュール名（*module name*）

　モジュール宣言において指定した名前。1つの名前を複数のモジュール単位で共有できる。

### ヘッダーユニット（*header unit*）

　従来のヘッダファイルを仮想的にモジュール単位として扱う仕組み、もしくはその場合のモジュール単位のこと。指定されたヘッダファイル1つで1つの翻訳単位をなす。

### 名前付きモジュール（*named module*）

　同じモジュール名を持つモジュール単位の集合。名前付きモジュールが1つのモジュールとなる。

ヘッダーユニットは名前付きモジュールではない（モジュール宣言によってモジュールとなるわけではないため）。

### エンティティ

　クラス、関数、変数など、C++コード上で名前を持つことができ、何かしらの意味論を持つものの総称。本書では主に、名前空間スコープに宣言できるものを対象にしている。

### エクスポート（`export`）

　あるモジュールのエンティティを、そのモジュール外部から使用できるようにするために、`export`を付加した宣言を行うこと。

### モジュールのインターフェース

　ある名前付きモジュールにおいて、モジュール宣言に`export`を含むモジュール単位の集合、もしくはそこでエクスポートされている宣言の集合。

### グローバルモジュールフラグメント

　あるモジュール単位において、モジュール宣言より前に`module;`というマーカーを置いた時、そこからモジュール宣言の直前までの領域の事。そこはモジュールには含まれない。

　グローバルモジュールフラグメントには直接的にはプリプロセッサディレクティブしか現れてはならない。

### グローバルモジュール

　グローバルモジュールフラグメントと全てのモジュール単位ではない翻訳単位の集合。

### モジュール単位の本文（*module unit purview*）

　モジュール宣言から始まりその翻訳単位の終わり（実質的にそのファイル末尾）までの部分に書かれている文字列。名前付きモジュールの本文とは、名前付きモジュールを構成する個々のモジュールの本文の集合。

　モジュール宣言から始まるため、グローバルモジュールフラグメントはモジュールの本文には含まれない。

　グローバルモジュールの本文とは、グローバルモジュールに現れている宣言全てのこと（グローバルモジュールフラグメントも含む）。

### モジュールに属する（*attached*）

　名前付きモジュールの本文内に書かれた宣言は全て、そのモジュールに属している。

　そうでないもの（グローバルモジュールフラグメント内宣言等）は、グローバルモジュールに属している。

### 可視（*visible*）

　名前探索においてエンティティの名前が見つかる場合、その名前は名前探索において可視であるという。

### 意味論的な性質（*semantic property*）

　あるエンティティの宣言もしくは翻訳単位の、C++コードとしての機能や性質のこと。宣言等は、意味論的な性質を利用可能となって初めてC++コード上で意味を持つ。

### 到達可能（*reachable*）

　あるソースコード上の一点から、ある宣言・翻訳単位の意味論的な性質を利用可能であるとき、その点からはそのような宣言・翻訳単位は到達可能であるという。

　あるいは、ある点からある宣言等へ到達可能であるとき、その宣言等の意味論的な性質を利用可能となる。

### インポート（`import`）

　ある翻訳単位でモジュールを利用するために`import`宣言を行うこと。モジュールをインポートすることによってその翻訳単位内からは、そのモジュールのインターフェースに含まれる宣言が全て到達可能になり、`export`されている宣言が可視になる。

### 再エクスポート（`export import`）

　モジュール内部において、他のモジュールをインポートすると同時にエクスポートすること。`export import modulename;`という宣言によって行われる。あるモジュール`A`で再エクスポートされているモジュールは、`A`内でインポートしたことになると同時に、`A`をインポートした翻訳単位でもインポートしたことになる。

\clearpage

# モジュールの基本

## モジュールのインターフェースと実装（*interface and implementation*）

　あるファイルをモジュールとして宣言するには、__モジュール宣言（*module decralation*）__をファイル先頭で行います。モジュール宣言を行うことでそのファイルは1つの __モジュール単位（*module unit*）__、かつ1つの翻訳単位となります。

```cpp
// 2つの形式のモジュール宣言の例
export module Module.Name;
module Module.Name;
```

　通常の多くのC++コードがヘッダファイル（宣言）とソースファイル（定義）に分割する様に、モジュールにおいても宣言と定義を別のファイル（別々のモジュール単位）に分割して実装します。その時、それらのモジュール単位はそれぞれ __モジュールインターフェース単位（*module interface unit*）__ と __モジュール実装単位（*module implementation unit*）__ と呼びます。


```cpp
///mymodule.cpp

// （プライマリ）モジュールインターフェース単位の宣言
export module MyModule;

// export宣言、宣言をモジュール外部に公開（可視かつ到達可能に）する
export int f(int n);
```
```cpp
///mymodule_impl.cpp

// モジュール実装単位の宣言
module MyModule;
// ここではプライマリモジュールインターフェース単位内のものが見えている
// モジュール外部からはこの中のものは可視でも到達可能でもない

// exportされたf()の再宣言・定義
int f(int n) {
  return n;
}
```
（この様なコードブロックの分割がファイル分割に対応していると思ってください）

　このように、`export module`の形のモジュール宣言によってインターフェース単位を宣言します。このインターフェース単位は __プライマリモジュールインターフェース単位（*primary module interface unit*）__ と呼ばれ、モジュールには必ず __唯一つだけ__ 含まれていなければなりません。  
　対して、`export`の付かないモジュール宣言でモジュール実装単位を宣言します。こちらは数の制限はありません。

　インターフェース単位にはモジュールのインターフェース、すなわち外部に公開する宣言を、実装単位にはそれら宣言の実装や内部詳細を、それぞれ書く事を想定しています。


　そして、このモジュールを利用するには次のようにします。

```cpp
///main.cpp（非モジュール）

// モジュール"MyModule"のインポート宣言、exportされているものを取り込む
import MyModule;

int main() {
  int n = f(10);  // ok、n = 10
}
```

　モジュールのインターフェースでは公開したい宣言をエクスポート宣言（`export 宣言;`）によって外部へ公開し、モジュールを利用する側（の翻訳単位）ではインポート宣言（`import モジュール名;`）によってモジュールからエクスポートされている宣言を取り込みます。

　この時、インポートされるのはモジュールのインターフェースのみであり、実装単位はインポートされず、インポートした側からは一切観測できません。すなわち、モジュール実装単位は従来のソースファイルのように定義を外部から隠蔽するのに利用することができます。

### モジュール名

　インターフェースと実装のどちらの宣言においても、`module`キーワードの後に指定するのがモジュール名で、予約語と`std`から始まる名前を除いて好きな名前を付けることができます。

　モジュール名に使用できる文字は、アルファベットと数字および`.`と`_`のみが使用できます。ただし、ユニバーサルキャラクタ名（=ユニコード文字）も使用可能ではあります。

モジュール名に使える文字の一覧
```
a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _

0 1 2 3 4 5 6 7 8 9

.

universal-character-name（省略）
```

ただし、`std`から始まる全てのモジュール名と予約語を含むようなモジュール名は、C++標準によって予約されたモジュール名であるため使用してはいけません。

```cpp
// ダメなモジュール名の例
export module std.mymodule;
export module std99.mymodule;
export module my__module;
export module _Mymodule;
export module module;
export module My＋module;
```

### モジュール実装単位とインポート

　モジュール実装単位とインターフェース単位は通常同じ名前を持ちます。すると、実装単位においてインターフェース単位をインポートしようとすると自分自身をインポートすることになってしまいます。いかなるモジュールも自分自身をインポートすることはできないのでそれをしようとするとエラーになります。

　しかし、モジュール実装単位は対応するプライマリモジュールインターフェース単位を暗黙的にインポートしているため、何もせずともそのまま対応するプライマリインターフェース単位に書かれた宣言を参照できます。

　これらのことから、モジュール実装単位そのものはエクスポートもインポートもできず、実装単位では`export`宣言出来ないことがわかります。

## パーティション（*partition*）

　さらに、モジュールを複数のファイルに分けて構成する事ができます。これは例えば、自作のライブラリを1つのモジュールとして提供したいが、その内部の実装においては整理のためにも複数のファイルに分けたい、という際に役立ちます。

　その様にモジュール内部で分割したファイルはこれもまたモジュール単位となり、 __モジュールパーテイション（*module partition*）__ と呼ばれます。

　そして、モジュールパーティションもまたインターフェースと実装に分割する事ができ、分割後のモジュール単位はそれぞれ __モジュールインターフェースパーティション（*module interface partition*）__、__モジュール実装パーティション（*module implementation partition*）__ と呼ばれ、それぞれモジュールインターフェース単位とモジュール実装単位でもあります。


```cpp
///mymodule_part.cpp

// モジュールインターフェースパーティションの宣言
export module MyModule:InterfacePart;

export double g(double v);
```
```cpp
///mymodule_part_impl.cpp

// モジュール実装パーティションの宣言
module MyModule:ImplPart;
// import宣言、モジュールパーティションMyModule:InterfacePartを取り込む
import :InterfacePart;

double g_impl(double v) {
  return v + v;
}

// パーティション":InterfacePart"内のg()の再宣言・定義
double g(double v) {
  return g_impl(v);
}
```
```cpp
///mymodule.cpp

// （プライマリー）モジュールインターフェース単位の宣言
export module MyModule;
// インターフェースパーティション":InterfacePart"の再エクスポート、必須
export import :InterfacePart;

export int f(int n);
```
```cpp
///mymodule_impl.cpp

// モジュール実装単位の宣言
module MyModule;

int f(int n) {
  return n;
}
```

　モジュールパーティションの宣言はモジュール宣言とほぼ同様ですが、モジュール名の後に`:パーティション名`を指定します（`:`がモジュールパーティションである証です）。そして、モジュールパーティションをインポートするときは`:`も含めたそのパーティション名だけを指定します。モジュール名は含めてしまうとコンパイルエラーになるので注意です。

　プライマリモジュールインターフェース単位はモジュールに一つしか作ることができませんが、インターフェースパーティションはいくつでも作ることができます。  
　ただし、同じモジュール内で複数のパーティションが同じ名前を持つことは出来ません。そのため、インターフェースパーティションと実装パーティションでは異なる名前を付ける必要があり、あるパーティションは使用する別のパーティションを明示的にインポートする必要があります。

　モジュールをパーティション分割しても、使用する側はそれを気にする必要はありません。

```cpp
///main.cpp
import MyModule;
// これはできないし、必要ない
//import MyModule:InterfacePart;

int main() {
  // 共に使用可能
  int    n = f(10);
  double v = g(1.0);

  // ng! 呼び出し不可能
  int m = g_impl(10);
}
```

　モジュールのパーティションへの分割はモジュールの外からは観測することができません。そのため、モジュールパーティションに存在する宣言へモジュール外部からアクセスすることはできません。

　また、モジュールパーティションはそのモジュール外からインポート出来ません。そのため、インターフェースパーティション内でエクスポートした宣言は全て、プライマリーモジュールインターフェース単位から再エクスポートされなければなりません。ただ、いくつもインターフェースパーティションがある場合に1つをエクスポートし忘れていた、などの場合でも恐らくコンパイラはエラーにはしません。

### パーティションとインターフェース・実装

　モジュールパーティションであったとしても、それ以前にインターフェース単位か実装単位のどちらかであるはずで、モジュール単位はパーティションかどうかとは関係なく、実装単位は実装単位のインターフェース単位はインターフェース単位のルールに従います。

　モジュール実装単位では`export`宣言を行うことができず、実装単位を再エクスポート（`export import`）することもできません実装単位にあるものはインターフェースでエクスポートしておかない限り、モジュール外部からは利用不可能です。

　ただし、インターフェースパーティションはプライマリとなることがないので複数のインターフェースが存在でき、実装単位がインポート出来ないのに対して実装パーティションは同じモジュール内からならばインポートすることが可能です。これらの点は非パーティションのモジュール単位とは異なります。

　モジュールパーティションを（同じモジュール内で）インポートした際は通常のインポートとは異なり、エクスポートされていない宣言も含めてそのパーティションのすべての宣言が利用可能になります。


## インターフェース？実装単位？？パーティション？？？

　そろそろ用語がこんがらがってきて何が何だか分からなくなってきたところでしょう・・・

　一応、ここまでに登場したモジュールは全部で4種類です。インターフェースか実装か？パーティションか否か？という2つの軸から分類でき、モジュール宣言に`export`が含まれていればインターフェース、モジュール名に`:`が含まれていればパーティション、というように見分けることができます。

モジュール種別とパーティションの直交関係

||インターフェース単位|実装単位|
|:---|:---:|:---:|
|非パーティション|プライマリモジュールインターフェース単位|モジュール実装単位|
|パーティション|モジュールインターフェースパーティション|モジュール実装パーティション|

各モジュールと対応するモジュール宣言

|モジュール種別|モジュール宣言例|
|:---|:---|
|プライマリモジュールインターフェース単位|`export module M;`|
|モジュール実装単位|`module M;`|
|モジュールインターフェースパーティション|`export module M:Part;`|
|モジュール実装パーティション|`module M:ImplPart;`|

## モジュールファイル形式

　ヘッダーやソースファイルがそうである様に、モジュールのソースファイルの拡張子は規定されていません。テキストファイルであり、コンパイラがそれと認識すればその拡張子は自由です。

　現在の所、MSVCでは`.ixx`、clangでは`.cppm`が使われているようですが、両コンパイラ共にそれ以外のファイルでもモジュールとして利用することができます（なお、どちらもまだ*experimental*な実装です）。

# 可視・到達可能

　__可視（*visible*）__ と __到達可能（*reachable*）__ はモジュール内の宣言や定義の参照についての2つの重要な概念です。この言葉をぬいてモジュールを説明していくのは少し難しいのでここでそれらの説明しておきます。

- 可視（*Visible*）
  - ある宣言は（3種類いずれかの）名前探索において見つかる（候補に上がる）時、そのコンテキストにおいて可視となる
- 到達可能（*Reachable*）
  - ある宣言は、（名前探索とは無関係に）その宣言の持つ意味論的な性質が利用可能である時、そのコンテキストにおいて到達可能となる

　可視という概念は同じ意味で元々使用されていました。到達可能はモジュールに伴って新しく導入された概念です。なお、コンテキスト（文脈）とはソースコード上でのある位置（点）のことです。

　宣言の持つ意味論的な性質とはその宣言についてC++コードとして規定された効果のことです。例えば、クラスの定義の持つ効果はクラスを完全型にしてそのメンバを利用可能にします。  
　逆にいうと、クラスの定義が到達可能であるときそのクラスは完全型となりそのメンバが利用可能になります。

　定義は必ず宣言を含むので、宣言が定義を兼ねている場合はその宣言に到達可能=定義に到達可能、ということになります。


# モジュールとODR

# `export`

# `import`

# 変なモジュール

## グローバルモジュール

### グローバルモジュールフラグメント

## ヘッダーユニット

### `#include`からの置換

## プライベートモジュールフラグメント（単一ファイルのモジュール）

# モジュールと`inline`

# モジュールとテンプレート

# ADL

\clearpage

# 謝辞

　本書を執筆するに当たっては、cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0に基づく)をとても参照しました。サイト管理者及び編集者の方々に厚く御礼申し上げます。
