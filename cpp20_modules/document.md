---
title: C++20 Modules
author: onihusube
date: 2020/01/05
geometry:
  width: 154cm
  height: 216cm
  margin: 1in
coverimage: cover.png
backcoverimage: backcover.png
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

## 本書の内容について

　本書ではC++20のモジュール仕様について、規格書の文面から読み取ることのできる理論的な部分を解説しています。従って、規格書では触れられていないビルドについてや`.dll, .lib, .so, .a`などの特殊な翻訳単位については触れていません。また、どう使うかよりはどういうものかのような理論的な側面を追求しているので、必ずしも実使用に当たって参考になるものではないかもしれません。なお、本書は以前に私が公開したブログ記事に加筆訂正を行ったものです。

　本書執筆時点では完全にモジュールを実装した処理系は存在していないため、本書の内容は実装に裏打ちされたものではなく、あくまで規格書から読み取った理論的なものにとどまります。その解釈にはおそらくいくつか間違いがあるかと思われます、ご了承ください。

　また、紙面の都合から下記の知っておいた方が良いと思われるトピックについては解説していません。分からない単語や概念に出くわしたら適宜調べてみることをお勧めします。

- 宣言と定義
- 翻訳単位
- ヘッダファイルと`#include`
- 分割コンパイル
- リンケージ
- 翻訳単位越え
- テンプレートのインスタンス化
- One Difinition Rule (ODR)とその例外
- 3種類の名前探索
- `inline`

## モジュールとは？

　モジュールとは、簡単に言えば従来のヘッダファイルとそのインクルードによるライブラリの導入を置き換えるシステムです。外部ライブラリの導入をモジュールのインポートによって行い、自作ライブラリでは公開したい宣言だけをエクスポートすることによって、ライブラリを使用・作成します。他の言語ではパッケージとかクレートとか呼ばれているものに相当し、より効率的なプログラムの分割・結合を可能にする仕組みです。

```cpp
// モジュールによるHello Worldの例
import <iostream>

int main() {
  std::cout << "Hello World!" << std::endl;
}
```

　現在（C++17までの）のC++にはこのような仕組みはなく、ライブラリの使用・配布はもっぱらビルド済みバイナリとヘッダーファイルの組み合わせや、ヘッダオンリーライブラリによって行われています。それらライブラリの使用時は、ライブラリの指定するヘッダーファイルを使用したい翻訳単位でインクルードすることによってライブラリのインターフェースにアクセスできるようにします。

　しかし、インクルードはC言語より引き継いだ古式ゆかしいシステムで、その実態はファイルのコピーアンドペーストであり、それにはいくつかの問題があります。

- 公開するものとしないものを選べない
    - 特に、マクロは名前空間を持たないので、一方的にばら撒かれる
- 翻訳単位ごとに同じヘッダをインクルードしていると、無駄にビルド時間が増大する
    - ヘッダオンリーライブラリにおいて顕著
- 思わぬ多重定義によるODR違反を引き起こしやすい
- ヘッダファイルと実装が別れている場合、それらが一致せずに未定義動作に陥る可能性がある

　もちろんインクルードにもメリットや便利なところもあるのですが、ライブラリの作成・配布という観点からは適切な仕組みであるとは言えません。他の言語はより高級なライブラリ管理のシステム（モジュールシステムだけではなく、パッケージマネージャも含めて）を持っており、C++にも渇望された結果、C++20にてモジュールが導入されるに至りました。

　上記で挙げたような問題はモジュールにおいては起こらないか、軽減されています。

\clearpage

# 言葉の前方宣言

　モジュールの説明ではどうしてもいくつか特有の言葉を導入しなければならず、しかもそれが前後しがちなので、事前に簡単かつ順番に言葉を定義しておきます。

一部の言葉は後で詳細に説明されます。

### モジュール宣言（*module decralation*）

　ある翻訳単位をモジュールを記述するものとして表明する宣言文。`export module modulename;`もしくは`module modulename;`のような宣言。

### モジュール単位（*module unit*）

　モジュール宣言を含む翻訳単位。

### モジュール名（*module name*）

　モジュール宣言において指定した名前。1つの名前を複数のモジュール単位で共有できる。

### ヘッダーユニット（*header unit*）

　従来のヘッダファイルを仮想的に1つのモジュール単位として扱う仕組み、もしくはその場合のモジュール単位のこと。指定されたヘッダファイル1つで1つの翻訳単位をなす。

### 名前付きモジュール（*named module*）

　同じモジュール名を持つモジュール単位の集合。名前付きモジュールが1つのモジュールとなる。

　ヘッダーユニットは名前付きモジュールではない（モジュール宣言によってモジュールとなるわけではないため）。

### エンティティ

　変数、関数、クラス型、列挙型、テンプレートなど、C++コード上で名前を持つことができ何かしらの意味論を持つものの総称。本書では主に、名前空間スコープに宣言できるものを対象にしている。

### エクスポート（`export`）

　あるモジュールのエンティティを、そのモジュール外部から使用できるようにするために、`export`を付加した宣言を行うこと。

### モジュールのインターフェース

　ある名前付きモジュールにおいて、モジュール宣言に`export`を含むモジュール単位でエクスポートされている宣言の集合。

### グローバルモジュールフラグメント

　あるモジュール単位において、モジュール宣言より前に`module;`というマーカーを置いた時、そこからモジュール宣言の直前までの領域の事。そこはモジュールには含まれない。

　グローバルモジュールフラグメントには直接的にはプリプロセッサディレクティブしか現れてはならない。

### グローバルモジュール

　グローバルモジュールフラグメントと全てのモジュール単位ではない翻訳単位の集合。

### モジュール単位の本文（*module unit purview*）

　モジュール宣言から始まりその翻訳単位の終わり（実質的にそのファイル末尾）までの部分に書かれている文字列。名前付きモジュールの本文とは、名前付きモジュールを構成する個々のモジュール単位の本文の集合。

　モジュール宣言から始まるため、グローバルモジュールフラグメントは名前付きモジュールの本文には含まれない。グローバルモジュールの本文とは、グローバルモジュールに現れている宣言全てのこと（グローバルモジュールフラグメントはそこに含まれる）。

### モジュールに属する（*attached*）

　名前付きモジュールの本文内に書かれた宣言は全て、そのモジュールに属している。

　そうでないもの（グローバルモジュールフラグメント内宣言等）は、グローバルモジュールに属している。

### 可視（*visible*）

　名前探索においてエンティティの名前が見つかる場合、その名前は名前探索において可視であるという。

### 意味論的な性質（*semantic property*）

　あるエンティティの宣言もしくは翻訳単位の、C++コードとしての機能や性質のこと。宣言等は、意味論的な性質を利用可能となって初めてC++コード上で意味を持つ。

### 到達可能（*reachable*）

　あるソースコード上の一点から、ある宣言・翻訳単位等の意味論的な性質を利用可能であるとき、その点からはそのような宣言・翻訳単位等は到達可能であるという。

　あるいは、ある点からある宣言等へ到達可能であるとき、その宣言等の意味論的な性質を利用可能となる。

### インポート（`import`）

　ある翻訳単位でモジュールを利用するために`import`宣言を行うこと。モジュールをインポートすることによってその翻訳単位内からは、そのモジュールのインターフェースに含まれる宣言が全て到達可能になり、`export`されている宣言が可視になる。

### 再エクスポート（`export import`）

　モジュール内部において、他のモジュールをインポートすると同時にエクスポートすること。`export import modulename;`という宣言によって行われる。あるモジュール`A`で再エクスポートされているモジュールは、`A`内でインポートしたことになると同時に、`A`をインポートした翻訳単位でもインポートしたことになる。

### プライベートモジュールフラグメント（*private module fragment*）

　1つのファイルでモジュールを構成しそのファイル内で公開するインターフェースと隠蔽する実装を分離する仕組み。`module private;`というマーカーが置かれた行を境に、その後に書かれたものはモジュール外から一切参照できない。

\clearpage

# モジュールの基本

## モジュールのインターフェースと実装（*interface and implementation*）

　あるファイルをモジュールとして宣言するには、__モジュール宣言（*module decralation*）__をファイル先頭で一度だけ行います。モジュール宣言を行うことでそのファイルは1つの __モジュール単位（*module unit*）__ かつ1つの翻訳単位となります。

```cpp
// 2つの形式のモジュール宣言の例
export module Module.Name;
module Module.Name;
```

　通常の多くのC++コードがヘッダファイル（宣言）とソースファイル（定義）に分割する様に、モジュールにおいても宣言と定義を別のファイル（別々のモジュール単位）に分割して実装します。その時、それらのモジュール単位はそれぞれ __モジュールインターフェース単位（*module interface unit*）__ と __モジュール実装単位（*module implementation unit*）__ と呼びます。


```cpp
///mymodule.cpp

// （プライマリ）モジュールインターフェース単位の宣言
export module MyModule;

// export宣言、宣言をモジュール外部に公開（可視かつ到達可能に）する
export int f(int n);
```
```cpp
///mymodule_impl.cpp

// モジュール実装単位の宣言
module MyModule;
// ここではプライマリモジュールインターフェース単位内のものが見えている
// モジュール外部からはこの中のものは可視でも到達可能でもない

// exportされたf()の再宣言・定義
int f(int n) {
  return n;
}
```
（この様なコードブロックの分割がファイル分割に対応していると思ってください）

　まず、`export module`の形のモジュール宣言によってインターフェース単位を宣言します。このインターフェース単位は __プライマリモジュールインターフェース単位（*primary module interface unit*）__ と呼ばれ、モジュールには必ず __唯一つだけ__ 含まれていなければなりません。

　インターフェース単位では、外部に公開したい（=外部からの参照を許可したい）宣言をエクスポート宣言（`export 宣言;`）によって宣言します。これによってその宣言はモジュールの外部から参照する事ができるようになります。例にあるように、エクスポート宣言は必ずしも定義を伴わなくても構いません。

次に、`export`の付かないモジュール宣言によってモジュール実装単位を宣言します。実装単位では、インターフェース単位で宣言されたものの定義を記述します。この時、何もせずとも実装単位からは同じ名前のプライマリインターフェース単位に書かれたものが見えています。

　このように、インターフェース単位にはモジュールのインターフェース、すなわち外部に公開する宣言を、実装単位にはそれら宣言の実装や内部詳細を、それぞれ書く事を想定しています。


　そして、このモジュールを利用するには次のようにします。

```cpp
///main.cpp（非モジュール）

// モジュール"MyModule"のインポート宣言、exportされているものを取り込む
import MyModule;

int main() {
  int n = f(10);  // ok、n = 10
}
```

　モジュールのインターフェースでは公開したい宣言をエクスポート宣言によって外部へ公開し、モジュールを利用する側ではインポート宣言（`import モジュール名;`）によってモジュールからエクスポートされている宣言を取り込みます。

　この時、インポートされるのはモジュールのインターフェースのみであり、実装単位はインポートされず、インポートした側からは一切観測できません。モジュール実装単位は定義を外部から隠蔽するために利用します。

### モジュール名

　インターフェースと実装のどちらの宣言においても、`module`キーワードの後に指定するのがモジュール名で、予約語と`std`から始まる名前を除いて好きな名前を付けることができます。

　モジュール名にはアルファベットと数字と`_`のみが使用できます（ユニバーサルキャラクタ名（=ユニコード文字）も使用可能ではあります）。そして、`.`をモジュール名の区切りとして使用可能です。

モジュール名に使える文字の一覧
```
a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _

0 1 2 3 4 5 6 7 8 9

universal-character-name（省略）
```

ただし、`std`から始まる全てのモジュール名と予約語を含むようなモジュール名は、C++標準によって予約されたモジュール名であるため使用してはいけません。

```cpp
// ダメなモジュール名の例
export module std.mymodule;
export module std99.mymodule;
export module my__module;
export module _Mymodule;
export module my.module;
export module My＋module;
```

### モジュール実装単位とインポート

　モジュール実装単位とインターフェース単位は通常同じ名前を持ちます。すると、実装単位においてインターフェース単位をインポートしようとすると自分自身をインポートすることになってしまいます。いかなるモジュールも自分自身をインポートすることはできないのでそれをしようとするとエラーになります。

　しかし、モジュール実装単位は対応するプライマリモジュールインターフェース単位を暗黙的にインポートしているため、何もせずともそのまま対応するプライマリインターフェース単位に書かれた宣言を参照できます。

　これらのことから、モジュール実装単位そのものはエクスポートもインポートもできず、実装単位では`export`宣言出来ないことがわかります。

## パーティション（*partition*）

　さらに、モジュールを複数のファイルに分けて構成する事ができます。これは例えば、自作のライブラリを1つのモジュールとして提供したいが、その内部の実装においては整理のためにも複数のファイルに分けたい、という際に役立ちます。

　その様にモジュール内部で分割したファイルはこれもまたモジュール単位となり、 __モジュールパーテイション（*module partition*）__ と呼ばれます。モジュールのパーティションを作るには、モジュール宣言においてモジュール名の後に`:`で区切ってパーティション名を指定します。なお、ここで指定するモジュール名は今ファイル分割しようとしているモジュール名を指定し、異なるモジュール名を指定してしまうと別のモジュールのパーティションだと認識されてしまいます。

```cpp
// モジュールパーティションの宣言例
export module Mymodule:IfPart;
module Mymodule:ImplPart;
```

　そして、モジュールパーティションもまたインターフェースと実装に分割する事ができ、分割後のモジュール単位はそれぞれ __モジュールインターフェースパーティション（*module interface partition*）__、__モジュール実装パーティション（*module implementation partition*）__ と呼ばれ、それぞれモジュールインターフェース単位とモジュール実装単位でもあります。

```cpp
///mymodule_part.cpp

// モジュールインターフェースパーティションの宣言
export module MyModule:InterfacePart;

export double g(double v);
```
```cpp
///mymodule_part_impl.cpp

// モジュール実装パーティションの宣言
module MyModule:ImplPart;
// import宣言、インターフェースパーティションMyModule:InterfacePartを取り込む
import :InterfacePart;

double g_impl(double v) {
  return v + v;
}

// パーティション":InterfacePart"内のg()の再宣言・定義
double g(double v) {
  return g_impl(v);
}
```
```cpp
///mymodule.cpp

// （プライマリー）モジュールインターフェース単位の宣言
export module MyModule;
// インターフェースパーティション":InterfacePart"の再エクスポート
export import :InterfacePart;

export int f(int n);
```
```cpp
///mymodule_impl.cpp

// モジュール実装単位の宣言
module MyModule;

int f(int n) {
  return n;
}
```

　モジュールパーティションの宣言はモジュール宣言とほぼ同様ですが、モジュール名の後に`:パーティション名`を指定します（`:`がモジュールパーティションである証です）。そして、モジュールパーティションをインポートするときは`:`を含めたそのパーティション名だけを指定します。モジュール名は含めてしまうとコンパイルエラーになるので注意です。

　プライマリモジュールインターフェース単位はモジュールに一つしか作ることができませんが、インターフェースパーティションはいくつでも作ることができます。  
　ただし、同じモジュール内で複数のパーティションが同じ名前を持つことは出来ません。そのため、インターフェースパーティションと実装パーティションでは異なる名前を付ける必要があり、あるパーティションは使用する別のパーティションを明示的にインポートする必要があります。

　モジュールをパーティション分割しても、使用する側はそれを気にする必要はありません。

```cpp
///main.cpp
import MyModule;
// これはできないし、必要ない
//import MyModule:InterfacePart;

int main() {
  // 共に使用可能
  int    n = f(10);
  double v = g(1.0);

  // ng! 呼び出し不可能
  int m = g_impl(10);
}
```

　モジュールのパーティションへの分割はモジュールの外からは観測することができないため、モジュールパーティションを指定してインポートする事は出来ません。そのため、モジュールインターフェースパーティションはプライマリーモジュールインターフェース単位から再エクスポートされなければなりません。ただ、いくつもインターフェースパーティションがある場合に1つをエクスポートし忘れていた、などの場合でも恐らくコンパイラはエラーにはしてくれません。

### パーティションとインターフェース・実装

　モジュールパーティションであったとしても、それ以前にインターフェース単位か実装単位のどちらかであるはずで、モジュール単位はパーティションかどうかとは関係なく、実装単位は実装単位のインターフェース単位はインターフェース単位のルールに従います。

　モジュール実装単位では`export`宣言を行うことができず、実装単位を再エクスポート（`export import`）することもできません実装単位にあるものはインターフェースで予め対応する宣言をエクスポートしておかない限り、モジュール外部からはアクセス不可能です。

　ただし、インターフェースパーティションはプライマリとなることがないので複数のインターフェースが存在でき、実装単位がインポート出来ないのに対して実装パーティションは同じモジュール内からならばインポートすることが可能です。これらの点は非パーティションのモジュール単位とは異なります。

　モジュールパーティションを（同じモジュール内で）インポートした際は通常のインポートとは異なり、エクスポートされていない宣言も含めてそのパーティションのすべての宣言が利用可能になります。


## インターフェース？実装単位？？パーティション？？？

　そろそろ用語がこんがらがってきて何が何だか分からなくなってきたところでしょう・・・

　一応、ここまでに登場したモジュールは全部で4種類です。インターフェースか実装か？パーティションか否か？という2つの軸から分類でき、モジュール宣言に`export`が含まれていればインターフェース、モジュール名に`:`が含まれていればパーティション、というように見分けることができます。

モジュール種別とパーティションの直交関係

||インターフェース単位|実装単位|
|:---|:---:|:---:|
|非パーティション|プライマリモジュールインターフェース単位|モジュール実装単位|
|パーティション|モジュールインターフェースパーティション|モジュール実装パーティション|

各モジュールと対応するモジュール宣言

|モジュール種別|モジュール宣言例|
|:---|:---|
|プライマリモジュールインターフェース単位|`export module M;`|
|モジュール実装単位|`module M;`|
|モジュールインターフェースパーティション|`export module M:IfPart;`|
|モジュール実装パーティション|`module M:ImplPart;`|

## モジュールファイル形式

　ヘッダーやソースファイルがそうである様に、モジュールのソースファイルの拡張子は規定されていません。テキストファイルであり、コンパイラがそれと認識すればその拡張子は自由です。

　現在の所、MSVCでは`.ixx`、clangでは`.cppm`が使われているようですが、両コンパイラ共にそれ以外のファイルでもモジュールとして利用することができます（なお、どちらもまだ*experimental*な実装です）。

\clearpage

# 可視・到達可能（*Visible and Reachable*）

　__可視（*visible*）__ と __到達可能（*reachable*）__ はモジュール内の宣言や定義の参照についての2つの重要な概念です。この言葉をぬいてモジュールを説明していくのは少し難しいのでここでそれらの説明しておきます。

- 可視（*Visible*）
  - ある宣言は（3種類いずれかの）名前探索において見つかる（候補に上がる）時、そのコンテキストにおいて可視となる
- 到達可能（*Reachable*）
  - ある宣言は、（名前探索とは無関係に）その宣言の持つ意味論的な性質が利用可能である時、そのコンテキストにおいて到達可能となる

　可視という概念は同じ意味で元々使用されていました。到達可能はモジュールに伴って新しく導入された概念です。

　コンテキスト（文脈）とはソースコード上でのある位置（点）のことで、宣言の持つ意味論的な性質とはその宣言についてC++コードとして規定された効果のことです。そして、到達可能とはソースコードのある位置からある宣言がC++コードとして利用可能であることを言います。

　例えば、クラスの定義の持つ効果はクラスを完全型にしてそのメンバを利用可能にします。逆にいうと、クラスの定義が到達可能であるときそのクラスは完全型となりそのメンバが利用可能になります。また、定義は必ず宣言を含むので、宣言が定義を兼ねている場合はその宣言に到達可能=定義に到達可能、ということになります。

## 可視＝到達可能？

　可視と到達可能の間には次のような関係性があります。

- 宣言が可視 → 宣言は到達可能：常に成り立つ
- 宣言が到達可能 → 宣言は可視：成り立たない事がある

　可視ではないということは名前探索で見つからないということなので、可視でなければその宣言は使用不可能です。そして、その宣言の持つC++コードとしての効果を利用するためには、その宣言が到達可能である必要があります。すなわち、モジュール内の宣言をモジュール外で利用するための必要十分条件は、その宣言が可視かつ到達可能であることです。

　ただしその定義の利用に関しては関数とそれ以外とで少し異なります。関数の場合は宣言だけが予めエクスポートされてさえいれば、再宣言で定義をしてもその宣言は外部リンケージを持つため、通常の翻訳単位越えによってその定義を呼び出すことができます。しかしそれ以外のもの（例えばクラス定義）はそうではなく、定義を伴わないエクスポート宣言の後でその定義が到達可能なところでなされないとモジュール外で定義を利用できません。

## *Spectre Declaration*

　前項の可視と到達可能の間にある関係性は、ある宣言が名前探索において見つからないにもかかわらず、その宣言の効果が利用可能であることがあり得ることを示唆しています。つまり、宣言が可視ではないのに到達可能となる事があるという事です。

　もっとも典型的な例はモジュールのインポートにおいて起こります。モジュールをインポートするとそのインターフェース（プライマリーインターフェース単位）内でエクスポートされている宣言はインポートした側で可視となり、同時に到達可能になります。  
　しかし、そのインターフェース内でエクスポートされていない宣言は可視にはなりませんが到達可能ではあります。このために意図しないODR違反が起こってしまう可能性があります。

　例えば次のように、プライマリインターフェース単位だけでモジュールを無理やり1ファイルで構成してみます。

```cpp
///mymodule.cpp
export module Mymodule;

// インポートした側からは可視ではないが到達可能
int f_impl(int n) {
  return n * n;
}

// インポートした側から可視であり到達可能
export int f(int n) {
  return f_impl(n);
}
```
```cpp
///main.cpp
import MyModule;

// ODR違反！モジュールの中身を知らずに定義してしまった、compile error!
int f_impl(int n) {
  return n + n;
}

int main() {
  int n = f(10);
  int m = f_impl(20); // compile error!
}
```

　インターフェースにある宣言はインポートした側からは全て到達可能となるため、インターフェースにエクスポートしていない宣言が含まれていると、その宣言は可視ではないが到達可能となります。もし、この宣言が定義を持ち、インポートした側でも同じ宣言に対して定義を書いてしまうとODR違反となります。幸い、これはコンパイルエラーになります。

　このような（1ファイルでモジュールを構成したい）場合、後述するプライベートモジュールフラグメントを利用することでこのような問題を回避しながら1ファイルモジュールを構成できます。

## クラス定義の可視性と到達可能性

　先ほど少し書きましたが、あるモジュールからクラスの宣言だけを`export`した場合、その定義の場所によってはそのモジュールをインポートした側からそのクラスを完全型として利用できない場合があります。

　クラスの定義を利用するには、そのクラスの宣言が可視であり、定義が少なくとも到達可能である必要があります。

```cpp
///mymodule.cpp
export module MyModule;

// 2つの型の宣言のみをエクスポート
export struct S1;
export struct S2;

// S1の再宣言・定義
struct S1 {
  double v = 1.0;
};

// S2を返す関数をエクスポート
export S2 f();
```
```cpp
///mymodule_impl.cpp
module MyModule;

// S2の再宣言・定義
struct S2 {
  int n = 10;
};

// f()の再宣言・定義
S2 f() {
  return { .n = 3 };
}
```
```cpp
///main.cpp
import MyModule;

int main() {
  S1 s1 = { .v = 3.1415 };  // ok、S1の定義は到達可能
  S2 s2 = { .n = 11 };      // ng、S2の定義は到達不可能
  S2* ps2{};    // ok
  s1.v = 0.0;   // ok
  
  auto r = f(); // ok
  S2   r = f(); // ng
  r.n  = 5;     // ng、S2の定義は到達不可能
}
```

　モジュールのインターフェース内の宣言は全てインポートした側から到達可能であり、クラスのメンバはクラスの定義が到達可能であれば可視となります。また、以前にエクスポートされた宣言の再宣言は暗黙にエクスポートされます。

　その結果、クラス`S1`の宣言・定義は`main.cpp`から可視かつ到達可能となり、そのメンバもまた可視となります。従って、初期化（構築）、メンバアクセスを普通に行えます。しかし、`S2`の定義は`MyModule`の実装単位にあり、インポートした側からは宣言は可視であるものの定義は到達可能ではありません。そのため、構築やメンバアクセスは行えず不完全型としての利用のみが可能です。

　ただし、`S2`のような型のオブジェクトを返す`f()`のような関数の戻り値は`auto`によって受けることだけは可能です。この場合でもメンバアクセスはおろかコピーもできず、実質的に`S2`の意味論的な性質を利用していないために可能なのだと思われます。


## 可視と到達可能の例

少し複雑ですがモジュールと可視・到達可能のサンプルコードを載せておきます。頑張って解読してみてください。

```cpp
///mymodule2.cpp
export module Mymodule2;

#include <iostream>

namespace Mymodule2 {

  export void print(int n);

  export void print(double v);

  void print(const char* str) {
    std::cout << str << std::endl;
  }

}

// プライベートモジュールフラグメントの開始
module : private;

namespace MyModule2 {

  void print(int n) {
    std::cout << n << std::endl;
  }

  void print(double v) {
    std::cout << v << std::endl;
  }
}
```
```cpp
///mymodule_part.cpp（インターフェースパーティション）
export module MyModule:InterfacePart;
//他モジュールの再エクスポート
export import Mymodule2;

export double h(double v);
```
```cpp
///mymodule_part_impl.cpp（実装パーティション）
module MyModule:ImplPart;
import :InterfacePart;

double h(double v) {
  MyModule2::print(v); //ok、可視であり到達可能

  return v + v;
}
```
```cpp
///mymodule.cpp（プライマリモジュールインターフェース単位）
export module Mymodule;
export import :InterfacePart;

export struct S;

export class C;

export int f(int n);

int g() {
  return 1;
}

//定義（再宣言）、以前にエクスポートされているため暗黙にエクスポート
class C {
  int m = 10;
public:
  C() = default;

  operator int() const noexcept {
    return m;
  }

  int set(int n);
};

```
```cpp
///mymodule_impl.cpp（実装単位）
module Mymodule;

struct S {
  int n;
  double v;
};

//定義（再宣言）、外部リンケージを持つ
int f(int n) {
  return n * n;
}

//定義（再宣言）、外部リンケージを持つ
int C::set(int n) const noexcept {
  int b = m;
  m = n;
  return b;
}

char get_a() {
  return 'a';
}

```
```cpp
///main.cpp
import Mymodule;

int main() {
  int n = f(2);         // ok、可視であり到達可能
  double d = h(0.1)     // ok、可視であり到達可能
  MyModule2::print(n);  // ok、可視であり到達可能
  S* ps = nullptr;      // ok、型名`S`は可視であり到達可能
  C c{};                // ok、クラス`C`の定義は到達可能
  int m = c;            // ok、`C`の定義は到達可能なので
                        // その全メンバの宣言も可視であり到達可能
  m = c.set(20);        // ok、`C`の宣言はエクスポートされており
                        // 外部リンケージを持ち、そのメンバも外部リンケージを持つ
                        // そして`C`の定義は到達可能なので全メンバの宣言は可視
                        // 実装単位内部の定義（再宣言）は外部リンケージを持つため
                        // 可視な宣言から呼び出しが可能

  int l = g();          // ng、到達可能だが可視ではない
  print("Hello World.");// ng、到達可能だが可視ではない

  S s = {10, 3.14};     // ng、`S`の型名は可視だが定義は到達可能ではない

  char a = get_a();     // ng、可視でも無く到達可能でもない
}

// 到達可能な定義と同名のものに対して定義をしてしまうとODR違反、コンパイルエラー
int g() {
  return 1;
}
```

プライベートモジュールフラグメントはまだ一切説明していないので、後で説明を読んで気が向いたら戻ってみてください・・・

\clearpage

# モジュールとODR

　1つの翻訳単位には、変数、関数、クラス型、列挙型、テンプレート、特定のスコープ内関数のデフォルト引数、デフォルトテンプレート引数、の定義を複数含めることはできません。そして、プログラムはそのようなODRに従った定義を1つだけ含んでいなければなりません。これを、__One Difinition Rule（単一定義原則 : ODR）__　と言います。

　通常、ODRに違反した場合は未定義動作になり、コンパイラはそれを検出しエラーを発する義務を負いません。従って、静かにバグを埋め込むことになります。

　基本的にはODRはモジュールにおいても変わりは無く、モジュールで翻訳単位を分割したとしてもODRを遵守しなくてはなりません。

## ODRの例外のモジュールにおける例外

　テンプレートなど、ヘッダに定義まで書いて複数翻訳単位からインクルードして利用されるものは各翻訳単位において定義がなされるため、一時的にはODRに違反しています。しかし、ODRの例外規定によってそれらは未定義動作とはならないようにされています。

　しかし、モジュールはヘッダのインクルードによって利用されることは無いため、このODRの例外は適用されません。そのため、実はモジュールにおいてはODRが厳しくなっています。

このことは次のように規定されています。

- 名前付きモジュールに属するエンティティは複数の定義を持ってはならない。その場合、後の定義が現れるときに前の定義が到達可能でなければ診断は不要
- ある宣言が別のモジュールに属した到達可能な宣言を再宣言する場合、プログラムはill-formd

これらの規則より、次の結論が導かれます。

* 1つのエンティティに対する宣言・定義は同じモジュールに属しており、名前付きモジュール内では定義は唯一つでなければならない
    + グローバルモジュールにおいては依然としてODRの例外規定が有効

　幸い、多くのケースではこれに違反するとコンパイラによってエラーとされるので気づく事ができます。診断不要と書いてある条件に引っかかるのは、異なるモジュールで同じ名前・シグネチャの関数などが定義されていて、それを1つのプログラム内の異なる翻訳単位から使用した、ような場合でしょう。

\clearpage

# モジュールリンケージ（*module linkage*）

　モジュールに属しかつ外部リンケージを持つ宣言（定義）が`export`されていないとき、これまでの規則で考えると対応する宣言を用意してやりさえすればモジュール外部から参照できるはずです。しかし、これをやられるとモジュールの意味が薄くなってしまうので出来ないようになっています。

- モジュールに属している宣言によって導入される名前が外部リンケージを持ちえるがエクスポートされていない場合、その名前は __モジュールリンケージ__ を持つ

　モジュールリンケージを持つ名前（変数名や関数名、クラス名など）は次の場所から参照され、参照することができます。

- 同じモジュール単位内の他のスコープにある名前
- 同じモジュール内の他のモジュール単位のスコープにある名前

　つまり、モジュールリンケージを持つ名前は同じモジュール内からしか参照できません。モジュール内では`export`宣言のみが名前に外部リンケージを与え、翻訳単位を超えて参照することができるのは外部リンケージを持つ名前だけです。

　なお、これらのことは宣言や定義が到達可能であるかどうかとは関係がありません。

\clearpage

# `export`

　モジュールインターフェース単位内で`export`によって宣言を外部公開する構文は、`export`宣言（エクスポート宣言）と呼びます。`export`宣言は伴う宣言の宣言としての効果（名前の導入等）を持ちます。逆に言うと、宣言できるものは基本的に`export`できます。

　`export`宣言によって導入・再宣言された名前はそのモジュールによって __エクスポートされている__ と言われます。エクスポートされた名前はそのモジュールをインポートしている翻訳単位内で可視となります。 


```cpp
///Mymodule.cpp
export module Mymodule;  //これはエクスポート宣言ではない

//エクスポート宣言の例

export struct S {
  int n = 10;
};

export int f() {
  return 0;
}

export int g();

int g() {
  return -1;
}

export int N = 10;

export inline constexpr double PI = 3.14159;
```

　`export`宣言はモジュールインターフェース単位の本文内の名前空間スコープ（グローバル名前空間を含む）で現れることができ、必ず何らかの名前を導入しなければなりません。そして、その名前は外部リンケージを持つ事ができる必要があります。

```cpp
///NG.cpp
export module NG;

// 以下全てNG集

// 内部リンケージ
export static int f() {
  return 0;
}

namespace {
  // 内部リンケージ
  export void f(int n) {}
}

// 内部リンケージ
export constexpr double PI = 3.14159; 

// 名前を宣言していない
export static_assert(true);

// 名前を宣言していない
export using namespace std;

// g()のエクスポート自体はok
export int g() {
  // 名前空間スコープではない（ローカルスコープ）
  export int n = 10;
  return n;
}

class S {
  int n = 0;
public:
  // 名前空間スコープではない（クラススコープ）
  export void set(int m) { n = m; }
};
```
```cpp
///NG_impl.cpp
module NG;

// モジュール実装単位にあらわれている
export int h();
```

　`export`宣言を出来るのはモジュールインターフェース単位内だけです。実装単位やモジュールでは無い翻訳単位ではできません。

## ブロック

　ちまちま1つづつ`export`を付けていくのがめんどくさい場合などに、`export`宣言をブロックによってまとめて行うことができます。この場合のブロックはスコープを導入せず、内部に`export`が現れてはいけません。

```cpp
///Mymodule.cpp
export module Mymodule;

// ブロックのエクスポート宣言、内部のものは暗黙的にエクスポートされる
export {
  struct S {
    int n = 10;
  };

  int f() {
    return 0;
  }

  inline constexpr double PI = 3.14159;

  // ng! exportキーワードは現れてはならない
  export int g() {
    return -1;
  }
}

// ok、ブロックのエクスポート宣言はスコープを導入しない
export inline constexpr PI_2 = 2.0 * PI;
```

## 名前空間

　`export`宣言は名前空間に対しても行うことができます。その場合、エクスポートされた名前空間内の宣言は暗黙的にエクスポートされることになります。従って、内部の宣言は全て外部リンケージを持つ必要があります。すなわち、無名名前空間は`export`宣言に関わってはいけません。

　また、エクスポートしていない名前空間内部に`export`宣言が現れることもできます。この時それを囲む名前空間は暗黙的にエクスポートされますが、エクスポートしていない宣言はエクスポートされません。

　ただし、ブロックのエクスポートと同じく、内部に`export`宣言を含んではいけません。

```cpp
///Mymodule.cpp
export module Mymodule;

// 名前空間のエクスポート宣言、内部のものは暗黙的にエクスポートされる
export namespace Mymodule {
  struct S {
    int n = 10;
  };

  int f() {
    return 0;
  }

  inline constexpr double PI = 3.14159;
}

namespace Detail {
  // 名前空間内でのエクスポート、Detail::g(void)がエクスポートされる
  // 同時に名前空間Detailもエクスポートされる
  export int g() {
    return -1;
  }

  // エクスポートしていない宣言はエクスポートされない
  int g(int n) {
    return -n;
  }
}

//ダメな例
export namespace NG {
  // 名前を宣言していない
  using namespace std;

  // 内部リンケージ
  static int N = 10;

  // exportキーワードは現れてはならない
  export int g() {
    return -1;
  }

  // 名前を宣言していない
  static_assert(true);

  // 無名名前空間は名前空間のエクスポート宣言に現れてはならない
  namespace {
    int h() {
      return 1;
    }
  }
}

// 無名名前空間はエクスポートできない（名前を宣言していない）
export namespace {
    int h() {
      return 1;
    }
}
```

## `using/typedef`

　`export`宣言は`using`（`typedef`）宣言に対しても行えます。ただし、名前を導入するものでなくてはならず、参照先の名前は外部リンケージを持っていなければなりません。

　ただし、`using`（`typedef`）による型エイリアスの宣言では、参照先の名前が外部リンケージを持つ必要はありません。

```cpp
///OtherModule.cpp
export module Other;

export int f() {
  return 0;
}

export int g() {
  return -1;
}

namespace Other{
  export struct S {
    int n = 10;
  };
}
```
```cpp
///Mymodule.cpp
export module Mymodule;
import Other;

export using ::f, ::g;  // ok、まとめてエクスポート！
export using Other::S;  // ok、import先では名前空間指定なしで利用できる

// ng!名前を宣言していない
export using namespace std;

static int h1() {
  return 1;
}

double h2(double v) {
  return v;
}

struct T {
  int n = 0;
  double v = 0.0;
}

// ng!内部リンケージを持つ名前のエクスポート
export using ::h1;

// ng!モジュールリンケージを持つ名前のエクスポート
export using ::h2
export using ::T;

// ただし型エイリアスならok
export using C1 = ::T;  // ::Tのエイリアスとなる名前C1をエクスポート
export typedef ::T C2;  // 同上
```

　型エイリアスのエクスポートでは元の名前がエクスポートされていなくても（可視でなくても）、インポートした側ではエイリアス名からその定義に到達可能になる事があります。

```cpp
///main.cpp
import Mymodule; // 先ほどのMymoduleがエラーを起こさなかったとして

int main() {
  C1 c1{};  // ok、型Tの定義は到達可能
  T  t{};   // ng、型Tは可視では無い
}
```

　ただし、この場合に`T`の定義が実装単位にあったりすsるとそれは到達可能ではありません。

## リンケージ指定

　変わったところではリンケージ指定もエクスポートできます。とはいえ、出来ることできないことはこれまでと変わりありません。

　ただ、この場合の宣言はエクスポートされたモジュールではなくグローバルモジュールに属する事になります。

```cpp
///Mymodule.cpp
export module Mymodule;

// リンケージ指定のエクスポート宣言
export extern "C" int f() {
  return 0;
}


// リンケージ指定ブロックのエクスポート宣言
// 内部のものは暗黙的にエクスポートされる
export extern "C" {
  int g() {
    return -1;
  }

  double PI = 3.14159;

  // ng!exportキーワードは現れてはならない
  export int h() {
    return 1;
  }

  // ng!内部リンケージ
  static int h() {
    return 1;
  }
}
```

## 再宣言と`export`

\clearpage

# `import`

## 再エクスポート

## 再インポート

　インポート宣言は同じモジュール名に対して複数回行うことができ、それは特に禁止されていません。

```cpp
//予め、モジュールA,Bがあるとして
///main.cpp
import A;
import B;

import A; //ok、#includeとは違い問題は起きない

int main() {}
```

　同じモジュールを何回インポートしても意味はなく、特に問題も起きません。なぜなら、先に述べたようにインポート宣言は指定したモジュール内の宣言が可視・到達可能となるかどうかのみを変更します。再度のインポートをしたとしても、すでに可視な宣言が可視に、到達可能な宣言が到達可能になるだけです。ODR違反等を起こしません。

## インターフェース依存関係

## 翻訳単位の到達可能性

## `import`プリプロセッシングディレクティブ

\clearpage

# 変なモジュール

## グローバルモジュール

### グローバルモジュールフラグメント

## ヘッダーユニット

### `#include`からの置換

## プライベートモジュールフラグメント（単一ファイルのモジュール）

\clearpage

# モジュールと`inline`

# モジュールとテンプレート

# ADL

\clearpage

# 謝辞

　本書を執筆するに当たっては、cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0に基づく)をとても参照しました。サイト管理者及び編集者の方々に厚く御礼申し上げます。

　また、twitter上で私の疑問に回答をくださった方々にも感謝します。
